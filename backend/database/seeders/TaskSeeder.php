<?php

namespace Database\Seeders;

use App\Modules\Learning\Infrastructure\Models\RoadmapBlock;
use App\Modules\Learning\Infrastructure\Models\Task;
use Illuminate\Database\Seeder;

/**
 * TaskSeeder - Comprehensive code-submittable tasks for AI evaluation
 * 
 * Each task is designed for students to upload code that can be evaluated by AI.
 * Task types: coding (write code), project (build application), theory (concepts)
 */
class TaskSeeder extends Seeder
{
    public function run(): void
    {
        $blocks = RoadmapBlock::all()->keyBy(function (RoadmapBlock $block) {
            return $block->level . '-' . $block->domain . '-' . $block->order_index;
        });

        $tasks = [
            // ══════════════════════════════════════════════════════════════════
            // BACKEND - BEGINNER LEVEL TASKS
            // ══════════════════════════════════════════════════════════════════

            // Block 1: Internet & Web Fundamentals
            ['key' => 'beginner-backend-1', 'title' => 'HTTP Request Analyzer', 'description' => 'Build a command-line HTTP request analyzer tool. Requirements: (1) Accept a URL and request method (GET/POST) as command-line arguments. (2) For POST requests, accept JSON body data. (3) Make the HTTP request and display: status code, response time in ms, all response headers (formatted as key: value), and total body length in bytes. (4) Handle network errors with clear error messages. Example usage: node http-analyzer.js GET https://api.github.com should output status, headers, and body size. Submit your complete code with a README showing example runs for both successful and failed requests.', 'type' => 'coding', 'difficulty' => 1, 'max_score' => 100],
            ['key' => 'beginner-backend-1', 'title' => 'DNS Lookup Tool', 'description' => 'Create a DNS resolution command-line tool. Requirements: (1) Accept a domain name as an argument (e.g., dns-lookup google.com). (2) Perform DNS resolution and display all IPv4 and IPv6 addresses found. (3) Show the DNS resolution time in milliseconds. (4) Handle invalid domains by showing a user-friendly error message. (5) Support batch lookup: accept multiple domains and display results for each. Example output format: "google.com resolved to: 142.250.184.46, 2607:f8b0:4004:c07::65 (23ms)". Include error handling for network failures and invalid domain formats.', 'type' => 'coding', 'difficulty' => 2, 'max_score' => 100],

            // Block 2: Terminal & OS Basics
            ['key' => 'beginner-backend-2', 'title' => 'File System Navigator', 'description' => 'Write a shell script (bash/PowerShell) that recursively lists files in a directory. Requirements: (1) Accept a directory path as the first argument (default to current directory if none provided). (2) Display each file with: relative path, size in human-readable format (KB/MB), and last modified date. (3) Add a --extension flag to filter by file type (e.g., --extension .js shows only JavaScript files). (4) Add a --sort flag to sort by size or date. (5) Calculate and display total size of all files found. Example: ./navigate.sh /home/user/projects --extension .py --sort size. Include help documentation showing all available flags.', 'type' => 'coding', 'difficulty' => 1, 'max_score' => 100],
            ['key' => 'beginner-backend-2', 'title' => 'Environment Setup Script', 'description' => 'Create an automated environment verification and setup script. Requirements: (1) Check if Node.js, Python 3, and Git are installed. For each, display version number or "Not installed". (2) Verify minimum versions: Node.js >= 16, Python >= 3.8, Git >= 2.0. (3) If any requirement is missing, provide installation instructions for the user\s OS. (4) Create a project directory structure: project-name/src, project-name/tests, project-name/docs. (5) Initialize a git repository in the project folder and create an appropriate .gitignore file. (6) Generate a README.md template with project name and detected environment info. Accept project name as argument. Example: ./setup.sh my-app creates my-app/ with all structure and checks.', 'type' => 'coding', 'difficulty' => 2, 'max_score' => 100],

            // Block 3: Programming Fundamentals
            ['key' => 'beginner-backend-3', 'title' => 'Calculator Application', 'description' => 'Build a command-line calculator with robust error handling. Requirements: (1) Accept mathematical expressions as input (e.g., "5 + 3", "10 / 2", "15 % 4"). (2) Support operations: addition (+), subtraction (-), multiplication (*), division (/), modulus (%). (3) Handle decimal numbers (e.g., "3.5 * 2"). (4) Validate inputs: reject invalid numbers, unknown operators, and expressions with wrong format. (5) Prevent division by zero with a clear error message. (6) Support chained operations: "5 + 3 * 2" should follow order of operations (result: 11). (7) Display results with up to 2 decimal places. (8) Include a help command showing usage examples. Test with: valid expressions, invalid operators, division by zero, and edge cases like negative numbers.', 'type' => 'coding', 'difficulty' => 1, 'max_score' => 100],
            ['key' => 'beginner-backend-3', 'title' => 'Array Manipulation Functions', 'description' => 'Implement a utility library with array manipulation functions. Requirements: Create these functions with exact specifications: (1) findMax(arr) - returns largest number, throws error if empty array. (2) findMin(arr) - returns smallest number. (3) average(arr) - returns mean value rounded to 2 decimals. (4) removeDuplicates(arr) - returns new array with unique values only, preserving order. (5) sortAscending(arr) - returns new sorted array (smallest to largest). (6) sortDescending(arr) - returns new sorted array (largest to smallest). For each function: write at least 3 test cases including edge cases (empty arrays, single element, negative numbers). Use a testing framework (Jest, Mocha, or built-in assertions). Submit with test results showing 100% pass rate.', 'type' => 'coding', 'difficulty' => 2, 'max_score' => 100],
            ['key' => 'beginner-backend-3', 'title' => 'Todo List CLI App', 'description' => 'Create a full-featured command-line todo list application. Requirements: (1) Commands: add "task description" - adds a new task, list - shows all tasks with IDs and status, complete <id> - marks task as done, remove <id> - deletes task, filter <active|completed|all> - shows filtered view. (2) Each task should have: unique ID, description, created date, completion status. (3) Persist data to a JSON file (todos.json) so tasks survive restarts. (4) Display tasks with formatting: "[✓] Task 1: Buy groceries (completed)" or "[ ] Task 2: Study programming (pending)". (5) Handle invalid commands and missing task IDs gracefully. (6) Add validation: prevent adding empty tasks, prevent completing non-existent tasks. Include a demo showing all commands working correctly.', 'type' => 'project', 'difficulty' => 3, 'max_score' => 100],

            // Block 4: Web Basics for Backend
            ['key' => 'beginner-backend-4', 'title' => 'Simple HTML Form', 'description' => 'Build a styled and validated HTML registration form. Requirements: (1) Create a form with these fields: Full Name (text input), Email (email input), Password (password input, min 8 chars), Confirm Password (password input), Submit button. (2) Add HTML5 validation: required attributes, email format validation, password minimum length. (3) Style the form with CSS: centered layout (max-width 400px), proper spacing between fields, styled input boxes with borders, hover effects on submit button, error message styling for invalid inputs. (4) Show custom validation messages when fields are invalid. (5) Ensure form is accessible: proper label associations, tab navigation works correctly. Submit the HTML file - it should work standalone in a browser. Test that validation prevents submission with invalid data.', 'type' => 'coding', 'difficulty' => 1, 'max_score' => 100],
            ['key' => 'beginner-backend-4', 'title' => 'Form Data Handler', 'description' => 'Write JavaScript to handle form submission with validation. Requirements: (1) Capture form submit event and prevent default page reload. (2) Validate all fields: Name must be at least 2 characters, Email must match email pattern, Password must be 8+ characters with at least one number and one uppercase letter, Confirm Password must match Password field. (3) Display validation errors below each invalid field in red text. (4) If all validations pass, display the submitted data in a formatted box: "Registration Successful! Name: [name], Email: [email]". (5) Clear form after successful submission. (6) Disable submit button during validation to prevent double submission. Include the complete HTML + JavaScript code. Test cases should cover: all valid data, missing fields, invalid email format, weak password, and non-matching password confirmation.', 'type' => 'coding', 'difficulty' => 2, 'max_score' => 100],

            // Block 5: Version Control with Git
            ['key' => 'beginner-backend-5', 'title' => 'Git Workflow Demo', 'description' => 'Create a demonstration repository showing complete Git workflow. Requirements: (1) Initialize a new repository and make an initial commit with a README file. (2) Create a feature branch named "feature/add-calculator" and switch to it. (3) Make 3 separate commits on the feature branch, each adding a different function (add, subtract, multiply). (4) Switch back to main branch and make a conflicting change to the same file. (5) Merge the feature branch into main and resolve the merge conflict. (6) Document every step in README.md with the exact Git commands used and screenshots/logs showing the conflict resolution. (7) Include a .gitignore file for your language. (8) Create at least one tag (v1.0.0). Submit the repository URL with clear commit history showing all steps.', 'type' => 'project', 'difficulty' => 2, 'max_score' => 100],
            ['key' => 'beginner-backend-5', 'title' => 'Git Hooks Setup', 'description' => 'Configure Git pre-commit hooks for code quality checks. Requirements: (1) Create a pre-commit hook script (in .git/hooks/ or using a tool like Husky) that runs before each commit. (2) The hook should: check code formatting/linting (ESLint, Pylint, or similar), run unit tests, and prevent commit if checks fail. (3) Include two test scenarios: a file with intentional linting errors (commit should be blocked), and a properly formatted file (commit should succeed). (4) Document setup instructions: how to install the hook, how to run checks manually, how to bypass the hook in emergencies (--no-verify). (5) Show console output examples of both failing and passing commits. Include a README explaining the quality checks enforced and how team members should set up the hooks.', 'type' => 'coding', 'difficulty' => 3, 'max_score' => 100],

            // Block 6: First Backend Framework
            ['key' => 'beginner-backend-6', 'title' => 'Hello World API', 'description' => 'Build your first REST API using Express.js, Flask, Laravel, or similar framework. Requirements: (1) Create GET /health endpoint that returns JSON: {"status": "healthy", "timestamp": "2026-01-05T10:30:00Z"}. (2) Create GET /info endpoint returning: {"api": "My First API", "version": "1.0.0", "description": "A simple REST API"}. (3) Server should run on port 3000 (or configurable via environment variable). (4) Add proper CORS headers to allow browser requests. (5) Include error handling for 404 routes: return {"error": "Route not found"} with 404 status. (6) Add logging: log each incoming request with method, path, and timestamp. (7) Create a README with: how to install dependencies, how to start the server, and example curl commands to test both endpoints. Test with curl or Postman and include response examples.', 'type' => 'coding', 'difficulty' => 1, 'max_score' => 100],
            ['key' => 'beginner-backend-6', 'title' => 'Notes CRUD API', 'description' => 'Build a complete CRUD REST API for managing notes. Requirements: (1) Implement endpoints: GET /notes (list all notes), GET /notes/:id (get single note), POST /notes (create note with title and content), PUT /notes/:id (update existing note), DELETE /notes/:id (delete note). (2) Use in-memory array storage (data resets on server restart). (3) Each note should have: id (auto-generated), title (string, required), content (string, required), createdAt (timestamp), updatedAt (timestamp). (4) Validation: return 400 if title or content is missing/empty. (5) Return 404 if note ID doesn\'t exist for GET/PUT/DELETE operations. (6) Response formats: POST returns created note with 201 status, PUT returns updated note, DELETE returns 204 no content, GET single returns note object, GET all returns array of notes. (7) Test all endpoints and include a Postman collection or curl examples for each operation. Document expected request/response formats.', 'type' => 'project', 'difficulty' => 2, 'max_score' => 100],
            ['key' => 'beginner-backend-6', 'title' => 'Request Validation Middleware', 'description' => 'Create reusable validation middleware for API request bodies. Requirements: (1) Write middleware function that accepts a validation schema (define structure for required fields, types, and constraints). (2) The middleware should: check if request body matches schema, validate field types (string, number, boolean, email), check required fields are present, validate constraints (min/max length, min/max value, regex patterns). (3) If validation fails, return 400 status with detailed errors: {"errors": [{"field": "email", "message": "Invalid email format"}, {"field": "age", "message": "Must be at least 18"}]}. (4) If validation passes, call next() to continue to route handler. (5) Create at least 3 example routes using the middleware: user registration (email, password, age), create post (title, content), update profile (name, bio). (6) Test with valid and invalid data, showing proper error responses. Include code examples of how to use the middleware in routes.', 'type' => 'coding', 'difficulty' => 3, 'max_score' => 100],

            // Block 7: Database Fundamentals
            ['key' => 'beginner-backend-7', 'title' => 'SQL Query Practice', 'description' => 'Write a comprehensive set of SQL queries demonstrating core operations. Setup: Create a "products" table with columns: id (INT, PRIMARY KEY, AUTO_INCREMENT), name (VARCHAR(100)), category (VARCHAR(50)), price (DECIMAL(10,2)), stock (INT), created_at (DATETIME). Insert 10 sample products across different categories. Required queries: (1) SELECT all products ordered by price descending, limit to 5 most expensive. (2) SELECT products WHERE category is "Electronics" AND price < 500. (3) INSERT a new product with all fields. (4) INSERT multiple products in a single statement (at least 3). (5) UPDATE price of all products in "Books" category, increase by 10%. (6) UPDATE stock for a specific product by id. (7) DELETE products WHERE stock = 0. (8) Use a transaction to safely delete a product only if stock is 0, rollback otherwise. Submit the SQL file with all queries, sample data, and comments explaining each query. Include expected result counts or sample output.', 'type' => 'coding', 'difficulty' => 1, 'max_score' => 100],
            ['key' => 'beginner-backend-7', 'title' => 'Database Schema Design', 'description' => 'Design a complete database schema for a library management system. Requirements: (1) Create "books" table: id, isbn (unique), title, publication_year, available_copies. (2) Create "authors" table: id, name, bio, birth_year. (3) Create "members" table: id, name, email (unique), phone, join_date, membership_status (active/inactive). (4) Create "loans" table: id, book_id, member_id, loan_date, due_date, return_date, status (active/returned/overdue). (5) Create "books_authors" junction table for many-to-many relationship: book_id, author_id. (6) Define proper constraints: PRIMARY KEY on all id columns, FOREIGN KEY relationships with ON DELETE CASCADE/RESTRICT where appropriate, UNIQUE constraints on isbn and email, NOT NULL constraints on required fields, DEFAULT values where sensible. (7) Add indexes on frequently searched columns (isbn, email, member_id in loans). (8) Write the complete SQL schema creation script with comments explaining each design decision. Include sample INSERT statements showing the relationships working.', 'type' => 'coding', 'difficulty' => 2, 'max_score' => 100],
            ['key' => 'beginner-backend-7', 'title' => 'CRUD with Database', 'description' => 'Extend your Notes API to use a real database (MySQL, PostgreSQL, or SQLite). Requirements: (1) Create notes table: id (primary key, auto-increment), title (varchar, not null), content (text), created_at (datetime), updated_at (datetime). (2) Set up database connection with: proper connection pooling, environment variables for credentials (DB_HOST, DB_USER, DB_PASS, DB_NAME), connection error handling. (3) Implement all CRUD operations using prepared statements/parameterized queries to prevent SQL injection: CREATE (INSERT), READ all and by id (SELECT), UPDATE by id, DELETE by id. (4) Update the updated_at timestamp automatically on every update. (5) Handle database errors gracefully: connection failures, duplicate entries, foreign key violations. Return appropriate HTTP status codes (500 for server errors, 404 for not found). (6) Add database migrations or schema file to set up tables. (7) Include .env.example file showing required configuration. Test all endpoints with actual database and include setup instructions in README.', 'type' => 'project', 'difficulty' => 3, 'max_score' => 100],

            // Block 8: First Deployment
            ['key' => 'beginner-backend-8', 'title' => 'Dockerfile Creation', 'description' => 'Write a production-ready Dockerfile for your Notes API. Requirements: (1) Use an official base image for your language (node:18-alpine, python:3.11-slim, or php:8.2-fpm). (2) Set working directory (/app). (3) Copy dependency files first (package.json, requirements.txt, composer.json) and install dependencies to leverage Docker layer caching. (4) Copy application source code. (5) Expose the port your app runs on (EXPOSE 3000). (6) Set environment variables with sensible defaults (NODE_ENV=production, PORT=3000). (7) Use non-root user for security (create and switch to app user). (8) Set the startup command (CMD). (9) Build the image and verify it runs: docker build -t notes-api . then docker run -p 3000:3000 notes-api. (10) Document the build and run commands in README. Show that the API responds correctly when running in container. Keep final image size under 200MB if possible.', 'type' => 'coding', 'difficulty' => 2, 'max_score' => 100],
            ['key' => 'beginner-backend-8', 'title' => 'Deployment Configuration', 'description' => 'Create complete deployment configuration for your Notes API. Requirements: (1) Write docker-compose.yml with three services: app (your API), database (MySQL/PostgreSQL), cache (Redis - optional but recommended). (2) Configure service dependencies: app depends on database. (3) Set up environment variables: use .env file for secrets (database password, API keys), define variables in docker-compose (DATABASE_URL, REDIS_URL). (4) Configure volumes: persist database data, mount source code in development mode for hot reload. (5) Add health checks: database health check (ping), app health check (HTTP request to /health endpoint). (6) Set restart policies (restart: unless-stopped). (7) Configure networking: create custom network for service communication. (8) Add a separate docker-compose.override.yml for development settings. (9) Document: how to start all services (docker-compose up), how to view logs, how to stop services, how to reset database. (10) Test the full stack starts correctly and the API can connect to the database. Include .env.example with all required variables.', 'type' => 'project', 'difficulty' => 3, 'max_score' => 100],

            // ══════════════════════════════════════════════════════════════════
            // BACKEND - INTERMEDIATE LEVEL TASKS
            // ══════════════════════════════════════════════════════════════════

            // Block 1: Production REST APIs
            ['key' => 'intermediate-backend-1', 'title' => 'Paginated List Endpoint', 'description' => 'Build a production-grade paginated API endpoint for listing items. Requirements: (1) Create GET /api/items endpoint accepting query parameters: page (default 1), limit (default 20, max 100), sort (field name), order (asc/desc). (2) Return response: {"data": [...items], "pagination": {"page": 1, "limit": 20, "total": 150, "totalPages": 8}, "links": {"first": "/api/items?page=1", "prev": null, "next": "/api/items?page=2", "last": "/api/items?page=8"}}. (3) Support sorting by any field: /api/items?sort=createdAt&order=desc. (4) Add filtering: /api/items?category=electronics&minPrice=100&maxPrice=500. (5) Validate inputs: reject invalid page numbers, limit values > 100, unknown sort fields. (6) Optimize database queries: use LIMIT/OFFSET, count total rows efficiently. (7) Add proper HTTP cache headers (ETag or Cache-Control). Test with 1000+ records, verify performance is acceptable, and show examples of all query combinations.', 'type' => 'coding', 'difficulty' => 3, 'max_score' => 100],
            ['key' => 'intermediate-backend-1', 'title' => 'File Upload API', 'description' => 'Create a complete file upload system with validation and storage. Requirements: (1) POST /api/upload/single - upload one file, return {"id": "uuid", "filename": "image.jpg", "size": 204800, "mimeType": "image/jpeg", "url": "/files/uuid.jpg"}. (2) POST /api/upload/multiple - upload up to 5 files at once, return array of file metadata. (3) GET /api/files/:id - retrieve/download uploaded file. (4) Validation: accept only images (jpg, png, gif) and PDFs, max size 5MB per file, reject invalid mime types. (5) Storage: save files to uploads/ directory with unique names (use UUID), prevent filename collisions. (6) Security: sanitize filenames, prevent path traversal attacks, validate file content (not just extension). (7) Error handling: return 400 for oversized files, 415 for unsupported types, 404 for missing files. (8) Add a DELETE /api/files/:id endpoint. Test with: valid images, oversized files, invalid file types, malicious filenames, and concurrent uploads.', 'type' => 'project', 'difficulty' => 4, 'max_score' => 100],
            ['key' => 'intermediate-backend-1', 'title' => 'API Error Handler', 'description' => 'Build a centralized error handling system for your API. Requirements: (1) Create error handler middleware that catches ALL errors (thrown errors, rejected promises, async errors). (2) Define error classes: ValidationError (400), UnauthorizedError (401), ForbiddenError (403), NotFoundError (404), ConflictError (409), InternalError (500). (3) Return consistent JSON format: {"error": {"code": "VALIDATION_ERROR", "message": "User-friendly message", "details": [...field errors], "timestamp": "2026-01-05T10:30:00Z", "path": "/api/users"}}. (4) Log errors: console in development, file/service in production, include stack trace for 500 errors only. (5) Hide sensitive info: never expose stack traces or internal paths to clients in production. (6) Handle specific cases: database errors, validation errors, JWT errors, file system errors. (7) Add request ID to all error responses for tracing. Create test routes that intentionally trigger each error type and verify proper responses.', 'type' => 'coding', 'difficulty' => 3, 'max_score' => 100],

            // Block 2: Authentication & Security
            ['key' => 'intermediate-backend-2', 'title' => 'JWT Authentication System', 'description' => 'Implement complete JWT-based authentication. Requirements: (1) POST /auth/register - create user with email, password (hash with bcrypt, cost factor 10), return user object (no password). (2) POST /auth/login - verify credentials, return {"accessToken": "jwt...", "refreshToken": "jwt...", "expiresIn": 3600}. (3) POST /auth/refresh - accept refresh token, return new access token. (4) POST /auth/logout - invalidate refresh token. (5) JWT payload: {"userId": 123, "email": "user@example.com", "iat": timestamp, "exp": timestamp}. (6) Access token expires in 1 hour, refresh token in 7 days. (7) Protect routes with auth middleware: verify JWT, attach user to request object, return 401 if invalid/expired. (8) Store refresh tokens in database with user_id, token hash, expiry date. (9) Validation: email format, password min 8 chars, prevent duplicate emails. (10) Security: use environment variable for JWT secret (min 32 chars), use HTTPS in production. Test: successful registration/login, invalid credentials, expired tokens, using access token on protected route.', 'type' => 'project', 'difficulty' => 4, 'max_score' => 100],
            ['key' => 'intermediate-backend-2', 'title' => 'Role-Based Access Control', 'description' => 'Add role-based authorization to your API. Requirements: (1) Define roles: admin (full access), moderator (read + update), user (read own data). (2) Add role field to users table with default "user". (3) Create authorization middleware: requireRole(["admin"]), requireRole(["admin", "moderator"]). (4) Implement permission checks: admins can access GET/POST/PUT/DELETE /api/users, moderators can only GET/PUT, users can only GET their own record. (5) Return 403 Forbidden if user lacks required role: {"error": "Insufficient permissions. Required role: admin"}. (6) Protect routes: GET /api/users (admin only), PUT /api/users/:id (admin or owner), DELETE /api/users/:id (admin only), GET /api/users/:id (all authenticated users). (7) Add middleware to check resource ownership: users can only edit their own profile unless admin. (8) Test scenarios: admin accessing all routes, user trying to access admin route (403), user editing own vs other\s profile. Document the permission matrix.', 'type' => 'coding', 'difficulty' => 4, 'max_score' => 100],
            ['key' => 'intermediate-backend-2', 'title' => 'Password Reset Flow', 'description' => 'Implement secure password reset functionality. Requirements: (1) POST /auth/forgot-password - accept email, generate secure reset token (crypto.randomBytes(32)), save token hash + expiry (1 hour) to database, simulate sending email (log token to console), return 200 even if email not found (prevent user enumeration). (2) POST /auth/reset-password - accept token and new password, verify token exists and not expired, hash new password, update user, invalidate token, return success message. (3) Token format: URL-safe, 64 characters, store as SHA-256 hash in database. (4) Security: tokens expire after 1 hour, one-time use only (delete after use), rate limit forgot-password endpoint (5 requests per hour per IP). (5) Validation: new password must be different from old, meet password requirements (min 8 chars, 1 uppercase, 1 number). (6) Edge cases: handle expired tokens (return specific error), invalid tokens, reusing same token. (7) Document the flow with sequence diagram. Test: successful reset, expired token, invalid token, rate limiting.', 'type' => 'coding', 'difficulty' => 3, 'max_score' => 100],

            // Block 3: GraphQL Basics
            ['key' => 'intermediate-backend-3', 'title' => 'GraphQL Schema Design', 'description' => 'Design a GraphQL schema for a blogging platform. Requirements: (1) Define types: type Post {id: ID!, title: String!, content: String!, author: Author!, comments: [Comment!]!, createdAt: String!, publishedAt: String}, type Author {id: ID!, name: String!, email: String!, posts: [Post!]!}, type Comment {id: ID!, text: String!, author: Author!, post: Post!, createdAt: String!}. (2) Implement queries: posts(limit: Int, offset: Int): [Post!]! (list all posts with pagination), post(id: ID!): Post (get single post with nested author and comments), authors: [Author!]! (list all authors), author(id: ID!): Author (get author with their posts). (3) Set up resolvers for nested fields: Post.author fetches author data, Post.comments fetches comments for that post, Author.posts fetches posts by that author. (4) Add search query: searchPosts(query: String!): [Post!]! (search by title or content). (5) Implement GraphQL server (Apollo Server, GraphQL Yoga, or similar). (6) Test queries in GraphQL Playground, demonstrate nested queries, show query with multiple levels of nesting. Submit schema file and example queries with responses.', 'type' => 'coding', 'difficulty' => 3, 'max_score' => 100],
            ['key' => 'intermediate-backend-3', 'title' => 'GraphQL Mutations', 'description' => 'Implement GraphQL mutations for content management. Requirements: (1) Define input types: input CreatePostInput {title: String!, content: String!, authorId: ID!}, input UpdatePostInput {title: String, content: String}. (2) Implement mutations: createPost(input: CreatePostInput!): Post! (create new post, validate all required fields, return created post with generated ID), updatePost(id: ID!, input: UpdatePostInput!): Post! (update existing post, only update provided fields, return updated post), deletePost(id: ID!): Boolean! (delete post and associated comments, return true if successful), createComment(postId: ID!, text: String!, authorId: ID!): Comment! (add comment to post). (3) Validation: check post exists before update/delete (throw error if not found), validate title is not empty, content has min 10 characters, author exists. (4) Error handling: return GraphQL errors with descriptive messages: "Post not found", "Title cannot be empty", "Author does not exist". (5) Test all mutations, show successful operations and error cases. Demonstrate cascading delete (deleting post removes comments).', 'type' => 'coding', 'difficulty' => 4, 'max_score' => 100],

            // Block 4: Advanced Database Design
            ['key' => 'intermediate-backend-4', 'title' => 'Complex SQL Queries', 'description' => 'Write advanced SQL queries for an e-commerce database. Setup: Create tables: customers, orders, order_items, products, categories. Insert sample data (50+ orders, 100+ products). Required queries: (1) INNER JOIN: get all orders with customer names and total amounts. (2) LEFT JOIN: list all customers including those with no orders (show 0 if no orders). (3) Multi-table JOIN: get order details with customer name, product names, quantities, and prices. (4) Subquery: find customers who spent more than average. (5) GROUP BY with HAVING: list customers with more than 5 orders. (6) Window function: rank products by revenue using ROW_NUMBER() OVER(). (7) Complex aggregation: monthly sales report showing total orders, revenue, and average order value per month. (8) Correlated subquery: for each product, show its price vs category average. Submit SQL file with all queries, sample output, and execution time for each.', 'type' => 'coding', 'difficulty' => 4, 'max_score' => 100],
            ['key' => 'intermediate-backend-4', 'title' => 'Database Migration System', 'description' => 'Build a custom database migration management system. Requirements: (1) Create migrations table: id, name, batch, executed_at. (2) CLI commands: migrate up (run pending migrations), migrate down (rollback last batch), migrate:create <name> (generate migration file), migrate:status (list all migrations and their status). (3) Migration file format: timestamp_migration_name.sql with -- UP and -- DOWN sections, or programmatic format with up() and down() functions. (4) Features: track which migrations ran in which batch, support transactions (rollback on error), validate migration files before running, prevent running same migration twice. (5) Implement at least 5 migrations: create_users_table, add_email_index, create_posts_table, add_user_id_foreign_key, add_timestamps_to_users. (6) Test: run all migrations up, then rollback one batch, then re-run. Document the migration workflow and show the migrations table state after each operation.', 'type' => 'project', 'difficulty' => 4, 'max_score' => 100],
            ['key' => 'intermediate-backend-4', 'title' => 'Query Optimization', 'description' => <<<'DESC'
Optimize slow database queries through indexing and query restructuring. Setup:
(1) Create a users table with 100,000 rows (use script to generate test data).
(2) Add a posts table with 500,000 rows linked to users.
(3) Identify slow queries: query to find all posts by users in a specific city, query to get top 10 users by post count, query to search posts by title.
(4) For each query: run EXPLAIN or EXPLAIN ANALYZE to see execution plan, note the execution time and rows scanned.
(5) Apply optimizations: add indexes on foreign keys, add composite indexes where appropriate, add full-text search index for titles.
(6) Re-run EXPLAIN after indexing, compare execution plans and times.
(7) Document: before/after execution times (aim for 10x improvement), which indexes were added and why, trade-offs (write performance, storage space).
(8) Show cases where indexes do not help or make things worse. Submit optimization report with metrics.
DESC
, 'type' => 'coding', 'difficulty' => 4, 'max_score' => 100],

            // Block 5: NoSQL & Caching
            ['key' => 'intermediate-backend-5', 'title' => 'MongoDB CRUD Operations', 'description' => 'Build a MongoDB-based product catalog API. Requirements: (1) Define schema: products collection with fields _id, name, description, price, category, tags array, stock, specifications object, reviews array with user/rating/comment/date, createdAt, updatedAt. (2) Implement operations: CREATE using insertOne() and insertMany(), READ using find() with filters like category Electronics, findOne() by ID, findOne() with nested query for reviews.rating gte 4. UPDATE using updateOne() to modify product, push to add review, inc to update stock. DELETE using deleteOne() by ID, deleteMany() for discontinued products. (3) Aggregation pipelines: calculate average rating per product, group products by category with count and total value, find top 10 reviewed products. (4) Indexing: create indexes on category, price, tags. (5) Test with 1000+ products, show query performance. Submit code with example queries and outputs demonstrating all operations.', 'type' => 'project', 'difficulty' => 3, 'max_score' => 100],
            ['key' => 'intermediate-backend-5', 'title' => 'Redis Caching Layer', 'description' => 'Add Redis caching to improve API performance. Requirements: (1) Set up Redis connection with error handling and connection pooling. (2) Implement cache middleware: cache GET /api/posts/:id for 5 minutes with key pattern post:id, cache GET /api/posts list for 1 minute with key pattern posts:page:num. (3) Cache strategy: check Redis first, if miss fetch from database and store in Redis, set appropriate TTL (time to live). (4) Cache invalidation: on POST/PUT/DELETE to /api/posts, delete related cache keys (individual post + list cache). (5) Implement cache-aside pattern: application checks cache, loads from DB on miss, updates cache. (6) Add cache statistics endpoint: GET /api/cache/stats showing hit rate, miss rate, total requests. (7) Handle edge cases: Redis connection failure (fallback to DB), expired cache, cache stampede (multiple requests miss simultaneously). (8) Performance test: measure response times with and without cache (aim for 10x improvement on cache hits). Document caching strategy and show metrics.', 'type' => 'coding', 'difficulty' => 4, 'max_score' => 100],

            // Block 6: ORM Mastery
            ['key' => 'intermediate-backend-6', 'title' => 'ORM Relationships', 'description' => 'Implement all relationship types using an ORM (Sequelize, TypeORM, Eloquent, or SQLAlchemy). Requirements: (1) One-to-One: User hasOne Profile, Profile belongsTo User. (2) One-to-Many: User hasMany Posts, Post belongsTo User. (3) Many-to-Many: Post belongsToMany Tags through post_tags junction table. (4) Define models with proper relationships and constraints. (5) Implement eager loading: fetch user with profile in one query (User.findOne({include: Profile})), fetch post with author and tags (Post.findByPk(1, {include: [User, Tags]})). (6) Demonstrate N+1 problem: loop through posts and fetch author for each (bad), then fix with eager loading (good). (7) Use lazy loading appropriately: load comments only when needed (post.getComments()). (8) Test cascading deletes: deleting user should delete profile but NOT posts (set to null or prevent delete). Include code examples showing relationship queries and performance comparison (N+1 vs eager loading).', 'type' => 'coding', 'difficulty' => 3, 'max_score' => 100],
            ['key' => 'intermediate-backend-6', 'title' => 'ORM Query Builder', 'description' => 'Build a flexible query builder for dynamic API queries. Requirements: (1) Accept query parameters: filter[status]=published&filter[category]=tech&sort=-createdAt&include=author,tags&page=2&limit=20. (2) Implement filtering: support operators (eq, ne, gt, lt, in, like), multiple filters ({status: \"published\", views: {gt: 100}}), nested filters ({\"author.role\": \"admin\"}). (3) Implement sorting: single field (?sort=title), multiple fields (?sort=category,-createdAt for ASC/DESC). (4) Implement pagination: page-based (page, limit) with metadata (totalPages, totalItems). (5) Implement relationship loading: include=author loads author relation, include=author.profile loads nested relations. (6) Build ORM query dynamically: parse query params, apply filters using where clauses, apply sorting using orderBy, apply includes using eager loading, apply pagination using limit/offset. (7) Return consistent API format with data and meta. (8) Validate inputs: reject invalid field names, unknown operators, invalid pagination values. Test with complex queries combining all features.', 'type' => 'project', 'difficulty' => 4, 'max_score' => 100],

            // Block 7: Background Jobs & Queues
            ['key' => 'intermediate-backend-7', 'title' => 'Email Queue System', 'description' => 'Implement async job processing using a queue (Bull, BullMQ, Celery, or Laravel Queues). Requirements: (1) Set up queue backend (Redis-based). (2) Create job types: SendWelcomeEmail, SendPasswordReset, SendWeeklyDigest. (3) Job structure: {type, payload, attempts, maxRetries, priority}. (4) Producer: POST /api/users -> after creating user, dispatch SendWelcomeEmail job to queue (do not block response). (5) Consumer/Worker: process that listens to queue, picks up jobs, executes email sending logic (simulate with console.log or actual SMTP). (6) Error handling: if job fails, retry up to 3 times with exponential backoff (1s, 4s, 9s), after max retries move to failed jobs queue. (7) Job monitoring: create endpoint GET /api/jobs/stats showing: pending count, processing count, completed count, failed count. (8) Features: job priorities (high priority for password reset), delayed jobs (schedule SendWeeklyDigest for specific time), job progress tracking. Test by queuing 100 jobs and monitoring worker processing. Document setup and monitoring.', 'type' => 'project', 'difficulty' => 4, 'max_score' => 100],
            ['key' => 'intermediate-backend-7', 'title' => 'Scheduled Tasks', 'description' => 'Create a cron-like task scheduler for recurring jobs. Requirements: (1) Implement scheduler engine: check every minute for tasks that should run, execute tasks at specified intervals, prevent duplicate execution. (2) Define tasks: DailyCleanup (runs at 2 AM daily, deletes old logs), HourlySync (runs at :00 every hour, syncs external data), WeeklyReport (runs Mondays at 9 AM, generates reports). (3) Task configuration: store in database or config file with: task name, schedule (cron expression or interval), enabled/disabled status, last run time, next run time. (4) Cron expressions: support */15 (every 15 min), 0 2 * * * (2 AM daily), 0 9 * * 1 (Mondays 9 AM). (5) Execution: create task executor that runs tasks in background, logs execution (start time, end time, status, errors), prevents overlapping executions (skip if previous run still active). (6) Management: CLI/API to list tasks, enable/disable tasks, trigger task manually, view execution history. (7) Monitoring: dashboard showing task schedules, last execution, next execution, success/failure counts. Test all three task schedules and document the scheduler behavior.', 'type' => 'coding', 'difficulty' => 4, 'max_score' => 100],

            // Block 8: Docker & Cloud Basics
            ['key' => 'intermediate-backend-8', 'title' => 'Multi-Container Setup', 'description' => 'Create production-ready multi-container application stack. Requirements: (1) docker-compose.yml with services: app (Node/Python/PHP API), db (PostgreSQL or MySQL), cache (Redis), nginx (reverse proxy). (2) App service: build from Dockerfile, expose port, environment variables from .env file, depends_on db and cache, restart policy. (3) Database service: use official image, set root password via environment, create named volume for data persistence (db-data:/var/lib/mysql), expose port only to internal network. (4) Redis service: use official image, named volume for persistence. (5) Nginx service: proxy requests to app container, serve static files, configure ports 80:80. (6) Networking: create custom bridge network, services communicate by service name (db:3306). (7) Health checks: db checks with mysqladmin ping, app checks with HTTP request to /health, Redis checks with redis-cli ping. (8) Environment: use .env file for secrets, .env.example for template. (9) Volumes: persist database data, Redis data, app logs. (10) Test: docker-compose up -d, verify all services healthy, test API through nginx, check logs, docker-compose down. Document complete setup process.', 'type' => 'project', 'difficulty' => 4, 'max_score' => 100],
            ['key' => 'intermediate-backend-8', 'title' => 'Cloud Deployment Pipeline', 'description' => 'Build complete CI/CD pipeline for automated deployment. Requirements: (1) Choose platform: GitHub Actions, GitLab CI, or Jenkins. (2) Pipeline stages: Lint -> Test -> Build -> Deploy. (3) Lint stage: run code linter (ESLint, Pylint), fail pipeline if linting errors. (4) Test stage: run unit tests, require 80% code coverage, fail if tests fail. (5) Build stage: build Docker image, tag with commit SHA and \"latest\", push to Docker Hub or GitHub Container Registry. (6) Deploy stage: deploy to cloud platform (Heroku, Railway, DigitalOcean, AWS, or Google Cloud), run only on main branch, run database migrations, perform health check after deployment. (7) Environment variables: store secrets in CI platform (API keys, database URLs), inject at runtime. (8) Notifications: send Slack/Discord notification on deployment success/failure. (9) Rollback: ability to redeploy previous version if health check fails. (10) Create .github/workflows/deploy.yml or equivalent. Test: push to main branch, verify pipeline runs, app deploys, and is accessible via public URL. Document the complete pipeline flow.', 'type' => 'project', 'difficulty' => 5, 'max_score' => 100],

            // ══════════════════════════════════════════════════════════════════
            // BACKEND - ADVANCED LEVEL TASKS
            // ══════════════════════════════════════════════════════════════════

            // Block 1: Microservices Architecture
            ['key' => 'advanced-backend-1', 'title' => 'Service Decomposition', 'description' => 'Decompose monolithic e-commerce into microservices. Requirements: (1) Identify bounded contexts: Users (auth, profiles), Products (catalog, inventory), Orders (cart, checkout, fulfillment). (2) Define service boundaries: each service owns its database (database-per-service), no shared tables. (3) Design APIs: REST endpoints for each service (Users: /api/users, /api/auth; Products: /api/products, /api/categories; Orders: /api/orders, /api/cart). (4) Data consistency: eventual consistency between services, sagas for distributed transactions. (5) Service communication: synchronous for queries (get product details), async for events (order placed). (6) Shared data: duplicate necessary data across services (denormalization), use events to sync. (7) Implement: create separate codebases/repos for each service, run on different ports. (8) Document architecture: service map diagram, API contracts (OpenAPI specs), data ownership matrix. Test by running all services independently. Submit architecture doc + working services.', 'type' => 'project', 'difficulty' => 5, 'max_score' => 100],
            ['key' => 'advanced-backend-1', 'title' => 'Inter-Service Communication', 'description' => 'Implement service-to-service communication patterns. Requirements: (1) Synchronous REST: Order service calls Product service to verify stock (HTTP GET /products/:id/stock), handle timeouts (5s), circuit breaker pattern (fail fast after 5 consecutive failures). (2) gRPC: implement gRPC for high-throughput internal calls, define .proto files, compare performance vs REST. (3) Async messaging: use RabbitMQ/Kafka for events (OrderPlaced event consumed by Inventory + Email services), publish/subscribe pattern. (4) Retry policies: exponential backoff for transient failures, idempotency keys to prevent duplicate processing. (5) Fallbacks: return cached/default data if service unavailable, degrade gracefully. (6) Service mesh (optional): implement with Istio/Linkerd for traffic management. (7) API versioning: support multiple API versions (/v1/, /v2/). (8) Contract testing: verify service contracts with Pact or similar. Document communication patterns used. Submit multi-service system demonstrating both sync/async patterns.', 'type' => 'project', 'difficulty' => 5, 'max_score' => 100],

            // Block 2: Message Queues & Event Systems
            ['key' => 'advanced-backend-2', 'title' => 'Event-Driven Order System', 'description' => 'Build event-driven order processing system. Requirements: (1) Event flow: OrderCreated → InventoryReserved → PaymentProcessed → OrderConfirmed → ShipmentScheduled. (2) Event structure: {eventId, eventType, aggregateId, timestamp, payload, version}. (3) Event bus: publish events to message broker (Kafka/RabbitMQ), use topics/exchanges for routing. (4) Consumers: Inventory service reserves stock, Payment service charges card, Notification service sends email, each consumes relevant events. (5) Saga pattern: orchestration or choreography for distributed transaction, compensating actions if step fails (unreserve stock if payment fails). (6) Event sourcing: store all events in event store, rebuild aggregate state by replaying events. (7) Idempotency: consumers check eventId to prevent duplicate processing. (8) Dead letter queue: failed events go to DLQ for manual review. (9) Event versioning: handle schema evolution (v1 vs v2 events). (10) Monitoring: track event lag, processing time, failure rates. Submit complete event-driven system with saga implementation.', 'type' => 'project', 'difficulty' => 5, 'max_score' => 100],
            ['key' => 'advanced-backend-2', 'title' => 'Message Queue Consumer', 'description' => 'Build production-ready message consumer. Requirements: (1) Consumer configuration: prefetch count (fetch 10 messages at a time), concurrency (process 5 messages in parallel). (2) Message acknowledgment: manual ack after processing succeeds, nack and requeue if processing fails. (3) Retry mechanism: retry failed messages up to 3 times with delays, exponential backoff (1min, 5min, 15min). (4) Dead-letter queue: after max retries, move to DLQ for investigation. (5) Exactly-once processing: use deduplication with message ID, store processed IDs in database. (6) Graceful shutdown: on SIGTERM, stop accepting new messages, finish processing current batch, close connections. (7) Error handling: catch all errors, log details, decide whether to retry or dead-letter. (8) Poison messages: detect messages that always fail, move to poison queue immediately. (9) Metrics: track messages processed/sec, average processing time, error rate. (10) Health check: endpoint showing consumer status, last processed message time. Test with simulated failures. Submit resilient consumer implementation.', 'type' => 'coding', 'difficulty' => 5, 'max_score' => 100],

            // Block 3: API Gateways & Service Discovery
            ['key' => 'advanced-backend-3', 'title' => 'API Gateway Implementation', 'description' => 'Set up API Gateway (Kong, NGINX, or Express Gateway). Requirements: (1) Routing: route /api/users/* to User service, /api/products/* to Product service, /api/orders/* to Order service. (2) Authentication: verify JWT at gateway, attach user context to forwarded request, return 401 if invalid. (3) Rate limiting: 100 req/min per API key, 1000 req/hour per IP, return 429 Too Many Requests when exceeded. (4) Request/response transformation: add correlation ID header, remove internal headers before response. (5) Aggregation: create composite endpoint that calls multiple services (/api/dashboard aggregates user + orders + products). (6) Caching: cache GET requests at gateway level, vary by query params. (7) Load balancing: distribute requests across multiple service instances (round-robin, least-connections). (8) Circuit breaker: fail fast when downstream service unhealthy. (9) Logging: log all requests with timestamp, method, path, status, duration. (10) Admin API: endpoints to manage routes, view metrics. Deploy gateway in front of microservices. Submit configuration + architecture.', 'type' => 'project', 'difficulty' => 5, 'max_score' => 100],
            ['key' => 'advanced-backend-3', 'title' => 'Service Registry', 'description' => 'Implement service discovery with Consul, Eureka, or etcd. Requirements: (1) Service registration: on startup, services register with registry (name, host, port, health check URL). (2) Health checks: registry pings /health every 10s, deregisters if 3 consecutive failures. (3) Service lookup: clients query registry for available instances of a service, get list of healthy endpoints. (4) Load balancing: client-side load balancing, select instance using round-robin or random. (5) Dynamic updates: watch for service changes, update clients instance list when services scale up/down. (6) Heartbeat: services send heartbeat every 30s, registry marks as dead if no heartbeat for 90s. (7) Metadata: store version, region, tags with each service instance. (8) DNS integration: services accessible via DNS (product-service.local resolves to instances). (9) Graceful deregistration: on shutdown, service deregisters itself immediately. (10) Monitoring: dashboard showing all services, instance count, health status. Test by starting/stopping service instances. Submit service discovery implementation.', 'type' => 'coding', 'difficulty' => 5, 'max_score' => 100],

            // Block 4: Cloud Architecture & Reliability
            ['key' => 'advanced-backend-4', 'title' => 'High Availability Setup', 'description' => 'Design HA system on cloud platform (AWS/GCP/Azure). Requirements: (1) Multi-zone deployment: deploy app instances across 3 availability zones. (2) Load balancer: Application Load Balancer distributes traffic, health checks remove unhealthy instances. (3) Auto-healing: replace failed instances automatically, use managed instance groups or auto-scaling groups. (4) Database: managed database with multi-AZ replication (RDS Multi-AZ, Cloud SQL HA), automatic failover. (5) Stateless apps: store sessions in Redis/Memcached, not on app servers, allows any instance to serve any request. (6) Health checks: implement /health endpoint checking DB connectivity, external dependencies. (7) Graceful degradation: if Redis down, continue with reduced functionality (no sessions but API works). (8) Monitoring: CloudWatch/Stackdriver alerts for high error rate, instance failures. (9) Disaster recovery: automated backups, tested restore procedures, RTO < 1 hour. (10) Cost optimization: use reserved instances for base load, spot/preemptible for burst. Document architecture with diagram. Test failover by terminating instances.', 'type' => 'project', 'difficulty' => 5, 'max_score' => 100],
            ['key' => 'advanced-backend-4', 'title' => 'Auto-Scaling Configuration', 'description' => 'Configure horizontal auto-scaling. Requirements: (1) Metrics: scale based on CPU (>70% add instance, <30% remove), memory, request count, custom metrics (queue depth). (2) Scaling policies: scale up by 2 instances when threshold exceeded, scale down by 1 every 5 minutes. (3) Min/max limits: minimum 2 instances (HA), maximum 10 instances (cost control). (4) Cooldown periods: 5 min cooldown after scale up (prevent thrashing), 10 min after scale down. (5) Warm-up time: newly launched instances have 120s to warm up before receiving full traffic. (6) Scheduled scaling: scale up before peak hours (8 AM), scale down after hours (10 PM). (7) Target tracking: maintain average CPU at 50%, auto-scaling adjusts capacity. (8) Testing: use load testing tool (k6, JMeter) to generate traffic, watch auto-scaling in action. (9) Metrics: collect scaling events, instance count over time, cost per day. (10) Notifications: alert on scaling events, max capacity reached. Demonstrate successful scale up and down. Submit config + load test results.', 'type' => 'project', 'difficulty' => 5, 'max_score' => 100],

            // Block 5: Kubernetes & Orchestration
            ['key' => 'advanced-backend-5', 'title' => 'Kubernetes Deployment', 'description' => 'Deploy app to Kubernetes cluster (Minikube, GKE, EKS, or AKS). Requirements: (1) Deployment manifest: replicas=3, rolling update strategy (maxSurge=1, maxUnavailable=0), resource limits (CPU 500m, memory 512Mi). (2) Service: ClusterIP service for internal communication, expose port 80. (3) ConfigMap: store non-sensitive config (API_URL, LOG_LEVEL), mount as env vars or volume. (4) Secret: store sensitive data (DB_PASSWORD, API_KEY), base64 encoded, mount securely. (5) Ingress: route external traffic to service, configure host (app.example.com), TLS termination. (6) Health probes: liveness probe (restart if unhealthy), readiness probe (remove from service if not ready), startup probe for slow-starting apps. (7) Persistence: PersistentVolumeClaim for stateful data, use StatefulSet if needed. (8) RBAC: create ServiceAccount with minimal permissions. (9) Network policies: restrict traffic between pods. (10) Deploy all manifests, verify pods running, test app via ingress. Submit K8s manifests + deployment guide.', 'type' => 'project', 'difficulty' => 5, 'max_score' => 100],
            ['key' => 'advanced-backend-5', 'title' => 'Helm Chart Creation', 'description' => 'Package app as Helm chart for reusable deployment. Requirements: (1) Chart structure: Chart.yaml (name, version, description), values.yaml (default values), templates/ (K8s manifests with templating). (2) Parameterization: use {{.Values.replicaCount}} in Deployment, {{.Values.image.repository}} and {{.Values.image.tag}}, make everything configurable. (3) Values file: set defaults (replicaCount: 3, image.tag: latest), document all values with comments. (4) Helpers: _helpers.tpl with reusable template snippets (app labels, selector labels). (5) Dependencies: if app needs database, add as chart dependency (Chart.yaml dependencies). (6) Hooks: pre-install hook for database migration, post-upgrade hook for smoke tests. (7) Notes: NOTES.txt shows how to access app after installation. (8) Packaging: helm package mychart, creates mychart-1.0.0.tgz. (9) Multiple environments: values-dev.yaml, values-prod.yaml for different configs, install with --values. (10) Test installation: helm install myapp ./mychart, helm upgrade, helm rollback. Submit Helm chart tested on K8s.', 'type' => 'project', 'difficulty' => 5, 'max_score' => 100],

            // Block 6: Domain-Driven Design
            ['key' => 'advanced-backend-6', 'title' => 'DDD Entity Implementation', 'description' => 'Implement e-commerce domain using DDD tactical patterns. Requirements: (1) Entities: Order (has ID, changes over time), OrderLine (part of Order aggregate). Identity based on ID, not attributes. (2) Value Objects: Money (amount + currency, immutable), Address (street, city, immutable), Email (validated string). Equality based on values. (3) Aggregates: Order is aggregate root, controls OrderLines, all changes go through Order methods, maintain invariants. (4) Invariants: enforce business rules (Order total = sum of line totals, minimum order amount $10, max 20 items). (5) Domain events: OrderPlaced, OrderShipped, OrderCancelled published when state changes. (6) Methods: Order.addItem(), Order.removeItem(), Order.ship(), Order.cancel() encapsulate business logic. (7) Repositories: OrderRepository interface (domain layer), implementation (infrastructure layer), load aggregates fully. (8) Factories: OrderFactory.create() handles complex construction logic. (9) Domain services: PricingService for calculations that do not fit in entities. (10) Test domain model: unit tests for all business rules, no infrastructure dependencies. Submit domain model code demonstrating all patterns.', 'type' => 'project', 'difficulty' => 5, 'max_score' => 100],
            ['key' => 'advanced-backend-6', 'title' => 'Repository Pattern', 'description' => 'Implement repository pattern with multiple storage backends. Requirements: (1) Repository interface (domain layer): interface UserRepository {getById(id), getAll(), save(user), delete(id)}, no infrastructure concerns. (2) In-memory implementation: for tests, store entities in Map/array, fast, no setup needed. (3) Database implementation: use ORM or query builder, map database rows to domain entities, handle transactions. (4) Repository methods: return domain entities (not DB models), throw domain exceptions (UserNotFound), no leaky abstractions. (5) Unit of Work: track changes, save all at once in transaction, rollback on error. (6) Specification pattern: reusable query criteria (isActive(), byEmail(email)), combine with AND/OR. (7) Pagination: repository method getAll(page, limit) returns Page<User> with total count. (8) Caching layer: wrap repository with caching decorator, transparent to consumers. (9) Dependency injection: inject repository implementations, easy to swap. (10) Tests: test both implementations against same interface contract. Submit repository pattern with 2+ backends.', 'type' => 'coding', 'difficulty' => 4, 'max_score' => 100],

            // Block 7: Observability & Monitoring
            ['key' => 'advanced-backend-7', 'title' => 'Metrics & Monitoring Dashboard', 'description' => 'Set up comprehensive monitoring with Prometheus + Grafana. Requirements: (1) Instrument app: expose /metrics endpoint in Prometheus format (prom-client, prometheus_client). (2) Custom metrics: counter for requests (http_requests_total{method, path, status}), histogram for response time (http_request_duration_seconds), gauge for active connections. (3) Business metrics: orders_total, revenue_total, failed_payments_total. (4) Prometheus config: scrape app metrics every 15s, retention 15 days, alert rules. (5) Grafana dashboard: panels showing request rate, error rate, P95 response time, memory usage, active users. (6) Alerts: alert if error rate > 5%, if response time P95 > 1s, if service down, send to Slack/PagerDuty. (7) Service-level indicators (SLIs): availability (uptime %), latency (P99 < 200ms), error rate (< 0.1%). (8) Recording rules: pre-compute expensive queries for dashboard performance. (9) Multi-service view: combine metrics from all microservices in one dashboard. (10) Runbooks: document alert response procedures. Submit Prometheus config + Grafana dashboard JSON.', 'type' => 'project', 'difficulty' => 5, 'max_score' => 100],
            ['key' => 'advanced-backend-7', 'title' => 'Distributed Tracing', 'description' => 'Implement distributed tracing with OpenTelemetry + Jaeger. Requirements: (1) Instrumentation: add OpenTelemetry SDK to all services, auto-instrument HTTP libraries. (2) Spans: create span for each operation (HTTP request, database query, external API call), parent-child relationships. (3) Trace context propagation: pass trace ID + span ID across service boundaries in headers (traceparent). (4) Span attributes: add metadata (http.method, http.status_code, db.statement, error flag). (5) Full request trace: API Gateway → User Service → DB, Product Service → DB, Order Service → Queue. One trace ID links all spans. (6) Jaeger UI: view trace timeline, identify bottlenecks (which service is slow), filter traces by status/duration. (7) Sampling: sample 10% of traces in production (reduce overhead), 100% in staging. (8) Performance impact: measure overhead (< 5% latency increase acceptable). (9) Error tracking: traces with errors highlighted in UI, link to logs. (10) Trace-based alerts: alert if P95 trace duration > threshold. Submit working tracing system with example traces.', 'type' => 'coding', 'difficulty' => 5, 'max_score' => 100],

            // Block 8: Advanced Security & IAM
            ['key' => 'advanced-backend-8', 'title' => 'OAuth 2.0 Provider', 'description' => 'Build OAuth 2.0 authorization server. Requirements: (1) Authorization Code flow: user redirects to /authorize, logs in, grants permissions, redirects back with code, client exchanges code for access token at /token. (2) Client Credentials flow: server-to-server auth, client sends client_id + client_secret to /token, receives access token. (3) Client registration: register OAuth clients with client_id, client_secret, redirect_uris, allowed scopes. (4) Scopes: define scopes (read:profile, write:orders), clients request scopes, user approves subset. (5) Token issuance: generate access token (JWT or opaque), refresh token, return with expires_in. (6) Token validation: resource servers verify access token, check scopes, reject if expired/invalid. (7) Refresh token flow: exchange refresh token for new access token, rotate refresh tokens. (8) PKCE: support PKCE for public clients (mobile/SPA), require code_challenge and code_verifier. (9) Consent screen: show user what permissions client requests, allow/deny. (10) Security: validate redirect_uri to prevent open redirect, use HTTPS only, rate limit /token endpoint. Submit OAuth server with client demo app.', 'type' => 'project', 'difficulty' => 5, 'max_score' => 100],
            ['key' => 'advanced-backend-8', 'title' => 'Security Audit Implementation', 'description' => 'Implement comprehensive audit logging system. Requirements: (1) Audit events: login (success/failure), logout, password change, user creation, permission change, data access (PII), data modification, failed authorization. (2) Audit log structure: {timestamp, eventType, userId, actorIP, resource, action, result, metadata}. (3) Storage: append-only audit log table, never update/delete records, separate from app database. (4) Tamper-proof: sign log entries with HMAC, store hash chain (each entry includes hash of previous entry). (5) Retention: keep audit logs for 7 years (compliance requirement), archive old logs to cheap storage. (6) Searchability: index by userId, eventType, timestamp for fast queries. (7) Audit trail UI: admins can search audit logs, filter by user/date/action, export to CSV. (8) Compliance: log access to sensitive data (credit cards, SSNs), include data classification. (9) Alerting: real-time alerts for suspicious patterns (10 failed logins in 1 min, privilege escalation, weekend admin access). (10) Log analysis: periodic reports showing security metrics, anomaly detection. Submit audit system with sample reports.', 'type' => 'coding', 'difficulty' => 4, 'max_score' => 100],

            // ══════════════════════════════════════════════════════════════════
            // FRONTEND - BEGINNER LEVEL TASKS
            // ══════════════════════════════════════════════════════════════════

            // Block 1: HTML Fundamentals
            ['key' => 'beginner-frontend-1', 'title' => 'Semantic HTML Page', 'description' => 'Build a blog post page using semantic HTML5 elements. Requirements: (1) Use proper document structure: <!DOCTYPE html>, <html lang="en">, <head> with meta charset and viewport, <body>. (2) Header section: <header> with site logo (image), <nav> with list of links (Home, About, Blog, Contact). (3) Main content: <main> containing <article> with blog post (use <h1> for title, <h2> for sections, <p> for paragraphs, <time> for publish date). (4) Sidebar: <aside> with "Related Posts" list and "About Author" section. (5) Footer: <footer> with copyright and social links. (6) Heading hierarchy: only one <h1>, proper nesting of h2-h6. (7) Use semantic elements: <figure> and <figcaption> for images, <blockquote> for quotes, <code> for code snippets. (8) Accessibility: all images have alt text, links have descriptive text (not "click here"). Validate with W3C validator (must pass with no errors). Submit HTML file that renders a complete, readable blog post.', 'type' => 'coding', 'difficulty' => 1, 'max_score' => 100],
            ['key' => 'beginner-frontend-1', 'title' => 'Accessible Form', 'description' => 'Create an accessible contact form following WCAG guidelines. Requirements: (1) Form fields: Name (text), Email (email), Phone (tel), Message (textarea), Contact Preference (radio: email/phone), Subscribe to newsletter (checkbox), Submit button. (2) Every input must have a <label> with for attribute matching input id. (3) Group radio buttons in <fieldset> with <legend> \"Preferred Contact Method\". (4) Use appropriate input types (email, tel) for browser validation. (5) Mark required fields with required attribute and visual indicator (*). (6) Add helpful placeholder text (\"e.g., john@example.com\"). (7) Include aria-describedby for additional hints (\"We will never share your email\"). (8) Ensure keyboard navigation works: all fields focusable, logical tab order. (9) Style focus states clearly (visible outline or highlight). (10) Test with keyboard only (no mouse) - verify you can complete and submit the form. Submit HTML that passes accessibility checks.', 'type' => 'coding', 'difficulty' => 2, 'max_score' => 100],

            // Block 2: CSS Fundamentals
            ['key' => 'beginner-frontend-2', 'title' => 'CSS Box Model Demo', 'description' => 'Create a visual demonstration of the CSS box model. Requirements: (1) Build 4 boxes side by side, each showing different box-sizing values. (2) Box 1: content-box with 200px width, 20px padding, 2px border, 10px margin - show actual rendered width (244px). (3) Box 2: border-box with 200px width, 20px padding, 2px border - show it stays 200px total. (4) Box 3: demonstrate margin collapsing (two boxes with 20px margins touching = 20px gap, not 40px). (5) Box 4: demonstrate negative margins. (6) Each box displays its properties inside using ::before pseudo-element. (7) Style with visible borders, background colors, and text labels. (8) Add a legend explaining content-box vs border-box. (9) Make it interactive: hovering a box highlights its padding (different color), border (thicker), and margin (show outline). (10) Include comments in CSS explaining each property. Submit HTML+CSS that clearly visualizes these concepts.', 'type' => 'coding', 'difficulty' => 1, 'max_score' => 100],
            ['key' => 'beginner-frontend-2', 'title' => 'Typography System', 'description' => 'Design a complete typography system using CSS custom properties. Requirements: (1) Define CSS variables: --font-primary, --font-secondary, --font-mono, --scale-ratio (1.25), --base-size (16px). (2) Create type scale: --text-xs through --text-4xl calculated using scale ratio. (3) Style all headings: h1-h6 with appropriate sizes, line-heights, margins, font-weights. (4) Paragraph styles: body text (1rem/1.6 line-height), lead text (larger intro paragraphs), small text. (5) Link styles: default color, hover (underline), visited, focus (outline). (6) List styles: unordered (custom bullet with ::before), ordered (styled numbers), nested lists with different markers. (7) Utility classes: .text-center, .text-bold, .text-italic, .text-uppercase. (8) Responsive: adjust base font size for mobile (14px) vs desktop (16px) using media queries. (9) Create a demo page showing all typography elements with labels. (10) Ensure readability: sufficient contrast, comfortable line length (60-75 characters). Submit styled HTML showcasing the complete system.', 'type' => 'coding', 'difficulty' => 2, 'max_score' => 100],
            ['key' => 'beginner-frontend-2', 'title' => 'Card Component', 'description' => 'Design a reusable product card component with advanced CSS. Requirements: (1) Card structure: image at top, title (h3), price (styled prominently), short description, \"Add to Cart\" button. (2) Fixed dimensions: 300px wide, height auto based on content. (3) Visual design: subtle shadow (box-shadow), rounded corners (border-radius 8px), border, white background. (4) Image: 100% width, fixed height 200px with object-fit: cover. (5) Hover effects: on hover, card lifts up (translateY(-5px)), shadow intensifies, slight scale transform. (6) Button: full width at bottom, gradient background, changes on hover, smooth transitions (0.3s ease). (7) Responsive: stacks in single column on mobile, 2 columns on tablet, 3-4 columns on desktop using flexible layout. (8) Details badge: position absolute \"Sale\" badge on top-right corner of image. (9) Add transition animations for all interactive states. (10) Create a demo with 6 cards showing the grid layout. Submit HTML+CSS with the card component fully styled.', 'type' => 'coding', 'difficulty' => 2, 'max_score' => 100],

            // Block 3: JavaScript Basics
            ['key' => 'beginner-frontend-3', 'title' => 'JavaScript Calculator', 'description' => 'Build a fully functional calculator with UI. Requirements: (1) UI: display screen showing current input/result, buttons for digits 0-9, operators (+, -, *, /, %), decimal point, equals, clear (C), and backspace. (2) Functionality: click digit buttons to build number, click operator to set operation, click equals to calculate result, chain operations (5 + 3 = 8, then * 2 = 16). (3) Display: show current operation above (e.g., \"5 + 3\"), show result below, update in real-time as buttons clicked. (4) Edge cases: prevent multiple decimals in one number (5.5.5 invalid), handle division by zero (show \"Error\"), limit display to 12 digits, clear on \"C\", delete last digit on backspace. (5) Operation logic: follow order of operations for chained calculations, clear previous result when starting new calculation. (6) Keyboard support: number keys, operator keys, Enter for equals, Escape for clear. (7) Style with CSS: grid layout for buttons, styled display, hover effects on buttons. (8) No eval() function - implement calculation logic manually. Test thoroughly with complex chains of operations.', 'type' => 'project', 'difficulty' => 2, 'max_score' => 100],
            ['key' => 'beginner-frontend-3', 'title' => 'Array Methods Practice', 'description' => 'Demonstrate mastery of JavaScript array methods with practical examples. Requirements: Create visualizations for these operations on a products dataset [{id, name, price, category, inStock}, ...]: (1) map(): transform products array to show only names and prices {name, price}. Display before/after. (2) filter(): filter products where price < $50, filter by category, filter in-stock items. Show filtered results. (3) reduce(): calculate total value of all products (sum of prices), find most expensive product. (4) find(): find first product in \"Electronics\" category, display result or \"not found\". (5) some(): check if any product is out of stock (inStock === false), show boolean result. (6) every(): check if all products are under $1000, show boolean. (7) Chain methods: products.filter(inStock).map(p => p.name).join(\", \") to get comma-separated names of in-stock items. (8) Display each operation with: code snippet, input data, output result, explanation text. Make it interactive: buttons to trigger each method, animated result display. Submit working HTML/JS demo.', 'type' => 'coding', 'difficulty' => 2, 'max_score' => 100],
            ['key' => 'beginner-frontend-3', 'title' => 'Form Validation', 'description' => 'Create registration form with comprehensive real-time validation. Requirements: (1) Form fields: Email, Password, Confirm Password, Age (number). (2) Email validation: check format with regex pattern for email, show error Invalid email format if wrong, checkmark icon if valid. (3) Password validation: minimum 8 characters, at least one uppercase letter, one number, one special character. Show strength indicator (Weak/Medium/Strong) with color-coded bar. List requirements below field, mark each as met/unmet with icons. (4) Confirm Password: must match password exactly, show Passwords do not match error if different. (5) Age: must be 18 or above, show Must be 18+ if invalid. (6) Real-time validation: validate on blur (when field loses focus), show errors immediately, remove errors when corrected. (7) Submit button: disabled until all fields valid, enabled with green color when ready. (8) On submit: if any field invalid, focus first error and prevent submission. If all valid, display success message with submitted data (except password). Test with various invalid inputs and verify appropriate errors appear.', 'type' => 'coding', 'difficulty' => 3, 'max_score' => 100],

            // Block 4: DOM Manipulation
            ['key' => 'beginner-frontend-4', 'title' => 'Interactive Todo List', 'description' => 'Build a feature-rich todo list application. Requirements: (1) UI: input field to add todos, list container, filter buttons (All/Active/Completed). (2) Add todo: type in input, press Enter or click Add button, creates new todo item, clears input. (3) Todo item structure: checkbox (for complete toggle), text label, delete button (×). (4) Toggle complete: click checkbox marks item complete (strike-through text, gray color), click again uncompletes. (5) Delete: click × button removes item with confirm prompt. (6) Filters: All shows all items, Active shows only incomplete, Completed shows only complete. Active filter highlights. (7) Use event delegation: single event listener on list container handles all todo clicks (not separate listener per item). (8) Local storage: save todos to localStorage on any change, load from localStorage on page load, todos persist across refreshes. (9) Empty state: show \"No todos yet. Add one above!\" when list empty. (10) Counter: show \"X active tasks\" count. Test: add 10 todos, complete some, filter, delete some, refresh page (todos should persist). Submit working HTML/CSS/JS.', 'type' => 'project', 'difficulty' => 3, 'max_score' => 100],
            ['key' => 'beginner-frontend-4', 'title' => 'Dynamic Content Loader', 'description' => 'Create a page that fetches and displays data dynamically. Requirements: (1) Use JSONPlaceholder API (https://jsonplaceholder.typicode.com/posts). (2) On page load: show loading spinner, fetch posts data, hide spinner, display posts. (3) Post display: create card for each post with title (h3), body text, user info (fetch from /users/:userId). (4) Dynamic DOM creation: use createElement(), appendChild() to build post cards (no innerHTML for arrays). (5) Loading states: skeleton loading UI (gray placeholder boxes) while fetching, smooth fade-in when data arrives. (6) Error handling: if fetch fails, show error message \"Failed to load posts. Please try again.\" with retry button. (7) Pagination: load 10 posts initially, \"Load More\" button fetches next 10, disable button when all loaded. (8) Styling: grid/flexbox layout, responsive, cards with hover effects. (9) Async/await syntax for API calls. (10) Show loading time in console. Test: initial load, load more functionality, error handling (try with invalid URL), inspect DOM to verify clean structure. Submit complete working demo.', 'type' => 'coding', 'difficulty' => 3, 'max_score' => 100],

            // Block 5: Responsive Design
            ['key' => 'beginner-frontend-5', 'title' => 'Flexbox Navigation', 'description' => 'Build a responsive navigation using Flexbox (no JavaScript). Requirements: (1) Desktop layout (>768px): logo on left (image or text), navigation links in center (Home, About, Services, Contact), CTA button on right ("Get Started"). Use justify-content: space-between and align-items: center. (2) Mobile layout (<768px): logo on left, hamburger icon (☰) on right (CSS only using :target or checkbox hack), links hidden by default. (3) Mobile menu: when hamburger activated, links display vertically in dropdown/slide-in panel. (4) Styling: 60px height, background color, links spaced evenly with hover effects (color change/underline). (5) Responsive breakpoint at 768px using @media query. (6) Accessibility: ensure keyboard navigation works, use semantic <nav> element. (7) Sticky navigation: position: sticky so it stays at top on scroll. (8) Test on mobile (< 768px), tablet (768-1024px), desktop (>1024px). Submit HTML+CSS showing all three layouts working.', 'type' => 'coding', 'difficulty' => 2, 'max_score' => 100],
            ['key' => 'beginner-frontend-5', 'title' => 'CSS Grid Gallery', 'description' => 'Create a responsive photo gallery using CSS Grid. Requirements: (1) Grid layout: mobile (1 column), tablet (2 columns), desktop (3-4 columns) using auto-fill/auto-fit. (2) Use grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)) for automatic responsiveness. (3) Image sizing: all images same height (300px) with object-fit: cover to prevent distortion. (4) Grid gap: 20px spacing between items. (5) Hover effects: on hover, image scales up slightly (transform: scale(1.05)), shows overlay with image title, smooth transition (0.3s ease). (6) Featured items: use grid-column: span 2 to make some images double-width. (7) Aspect ratio boxes: maintain 16:9 ratio using padding-bottom trick or aspect-ratio property. (8) Add subtle border-radius and box-shadow to cards. (9) Bonus: implement masonry-style layout using grid-auto-flow: dense. (10) Include 12+ images in gallery. Test responsiveness by resizing browser. Submit HTML+CSS with beautiful gallery layout.', 'type' => 'coding', 'difficulty' => 3, 'max_score' => 100],
            ['key' => 'beginner-frontend-5', 'title' => 'Responsive Landing Page', 'description' => 'Build a complete, mobile-first landing page for a fictional product. Requirements: (1) Hero section: full viewport height (100vh), background image/gradient, centered heading + subheading + CTA button, looks good on all screen sizes. (2) Features section: 3-column grid on desktop, 1 column on mobile, each feature has icon, title, description. Use CSS Grid or Flexbox. (3) Testimonials section: horizontal scroll on mobile, 3 cards side-by-side on desktop, customer photo + quote + name. (4) Footer: 3 columns on desktop (About, Links, Contact), stacks vertically on mobile, social media icons. (5) Responsive images: use srcset or picture element for different screen sizes, ensure images don\'t overflow. (6) Typography: scale font sizes for mobile vs desktop (use clamp() or media queries). (7) Navigation: sticky header as per previous task. (8) Breakpoints: 480px (mobile), 768px (tablet), 1024px (desktop). (9) CSS techniques: use rem units, CSS variables for colors/spacing, mobile-first approach (base styles for mobile, media queries for larger screens). (10) Performance: optimize images, minimize CSS. Test on actual mobile device or Chrome DevTools. Submit complete HTML+CSS landing page.', 'type' => 'project', 'difficulty' => 3, 'max_score' => 100],

            // Block 6: Version Control with Git
            ['key' => 'beginner-frontend-6', 'title' => 'Git Portfolio Setup', 'description' => 'Set up a professional GitHub repository for your portfolio site. Requirements: (1) Create new GitHub repository named "portfolio" with description and README checkbox. (2) Clone to local machine: git clone <url>. (3) Project structure: index.html, styles.css, scripts.js, images/ folder, README.md. (4) Create .gitignore file: ignore .DS_Store, node_modules/, *.log, .env files. (5) Initial commit: git add ., git commit -m "Initial commit: project structure", git push origin main. (6) README.md content: project title, description, screenshot/demo link, features list, technologies used, setup instructions, contact info. Use proper Markdown formatting. (7) Make meaningful commits: separate commit for HTML structure, CSS styling, JS functionality (not one big commit). Good commit messages: "Add responsive navigation", "Implement contact form validation", "Fix mobile layout issues". (8) Add topics/tags to repo (html, css, javascript, portfolio). (9) Enable GitHub Pages: Settings > Pages > deploy from main branch. (10) Document Git commands used in a SETUP.md file. Verify portfolio is live at username.github.io/portfolio.', 'type' => 'project', 'difficulty' => 2, 'max_score' => 100],
            ['key' => 'beginner-frontend-6', 'title' => 'Branching Strategy Demo', 'description' => 'Demonstrate Git branching workflow with pull requests. Requirements: (1) Start with existing repo from previous task. (2) Create feature branch: git checkout -b feature/add-projects-section. (3) On feature branch: add new "Projects" section to portfolio, make 3 commits showing iterative development (structure, styling, content). (4) Push branch: git push origin feature/add-projects-section. (5) Create Pull Request on GitHub: descriptive title, explain changes in description, add screenshot if applicable. (6) Create second branch: git checkout main, git checkout -b feature/update-contact. Make changes to contact section. (7) Simulate conflict: on main branch, edit same file in same place as feature/update-contact branch. Commit on main. (8) Try to merge feature branch: git checkout feature/update-contact, git merge main (this creates conflict). (9) Resolve conflict: open conflicted file, choose which changes to keep, remove conflict markers (<<<<, ====, >>>>), git add, git commit. (10) Complete PR: merge feature branch to main via GitHub PR interface. (11) Document entire process in BRANCHING.md: commands used, screenshots of conflict resolution, explanation of when to use branches. Submit repo link showing commit history, closed PRs, and documentation.', 'type' => 'project', 'difficulty' => 2, 'max_score' => 100],

            // Block 7: Package Management & Tooling
            ['key' => 'beginner-frontend-7', 'title' => 'NPM Project Setup', 'description' => 'Set up a modern JavaScript project with npm. Requirements: (1) Initialize project: npm init, fill in name, version (1.0.0), description, entry point (index.js), author, license (MIT). This creates package.json. (2) Install dependencies: npm install --save-dev eslint prettier vite, npm install axios (example runtime dependency). (3) Understand package.json structure: name, version, scripts, dependencies vs devDependencies. (4) Create npm scripts in package.json: "dev": "vite" (runs dev server), "build": "vite build" (production build), "lint": "eslint .", "format": "prettier --write .". (5) Run scripts: npm run dev, npm run build, npm run lint. (6) Understand node_modules: where packages are installed, why it\s in .gitignore, package-lock.json purpose (locks exact versions). (7) Install global vs local packages: npm install -g vs npm install. (8) Create .npmrc file for configuration (registry, save-exact settings). (9) Document in README: required Node.js version (use "engines" field), installation steps (npm install), available scripts. (10) Bonus: explore package.json fields (keywords, repository, bugs). Submit complete project structure with package.json showing all scripts working.', 'type' => 'coding', 'difficulty' => 2, 'max_score' => 100],
            ['key' => 'beginner-frontend-7', 'title' => 'Build Tool Configuration', 'description' => 'Configure Vite for a vanilla JavaScript project. Requirements: (1) Project structure: src/main.js (entry point), src/styles.css, index.html, public/images/. (2) Install Vite: npm install --save-dev vite. (3) Create vite.config.js: define root, base, build output directory (dist), public directory. (4) Configure dev server: port (3000), open browser automatically, enable hot module replacement (HMR). (5) HTML entry: index.html should import script as module (<script type="module" src="/src/main.js">), link to CSS. (6) Asset handling: images in public/ accessible at /images/, images imported in JS bundled with hash names. (7) Environment variables: create .env file with VITE_API_URL=http://localhost:8000, access in code with import.meta.env.VITE_API_URL. (8) Build configuration: minification enabled, source maps for production, chunk splitting. (9) Scripts in package.json: "dev": "vite", "build": "vite build", "preview": "vite preview" (test production build locally). (10) Test: run dev server (should hot reload on changes), run build (should create optimized dist/ folder), run preview (serve built files). Submit complete configuration with working dev and build processes. Verify built files are minified.', 'type' => 'coding', 'difficulty' => 3, 'max_score' => 100],

            // Block 8: First Framework Project
            ['key' => 'beginner-frontend-8', 'title' => 'Counter Component', 'description' => 'Build a counter component using React or Vue. Requirements: (1) Component state: count variable initialized to 0. (2) Three buttons: Increment (+1), Decrement (-1), Reset (back to 0). (3) Display: show current count in large text. (4) Logic: increment adds 1, decrement subtracts 1, reset sets to 0. (5) React: use useState hook (const [count, setCount] = useState(0)), update with setCount(count + 1). Vue: use ref (const count = ref(0)), update with count.value++. (6) Styling: center the component, style buttons with different colors (green for increment, red for decrement, blue for reset), add hover effects, make count display prominent. (7) Edge case: prevent count from going below 0 (disable decrement button when count is 0, or show warning). (8) Bonus: add increment by 5 and decrement by 5 buttons, add input field to increment by custom amount. (9) Test: verify all buttons work, verify reset works, verify state updates display immediately. (10) Submit component code with clear comments explaining state management. Include screenshot showing the working counter.', 'type' => 'coding', 'difficulty' => 2, 'max_score' => 100],
            ['key' => 'beginner-frontend-8', 'title' => 'Todo App with Framework', 'description' => 'Build a complete todo application using React or Vue. Requirements: (1) Component structure: App component (main), TodoInput component, TodoList component, TodoItem component. (2) State management: todos array [{id: 1, text: "Learn React", completed: false}, ...], store in App component state. (3) Features: add todo (input field + add button), display all todos in list, toggle complete (checkbox), delete todo (X button), filter tabs (All/Active/Completed). (4) Add todo: press Enter or click Add button, clear input after adding, generate unique ID (Date.now() or uuid). (5) Toggle complete: click checkbox toggles completed property, apply strikethrough style to completed todos. (6) Delete todo: click X button removes todo from array, show confirmation dialog. (7) Filters: All shows all todos, Active shows incomplete only, Completed shows complete only. Highlight active filter. (8) Props flow: App passes todos array and handler functions (addTodo, toggleTodo, deleteTodo) to child components. TodoList maps over todos to render TodoItem components. (9) Styling: clean UI with proper spacing, color-coded completed items, responsive layout. (10) Local storage: save todos to localStorage on every change, load from localStorage on mount. Test by refreshing page - todos should persist. Submit complete app with all components and functionality working.', 'type' => 'project', 'difficulty' => 3, 'max_score' => 100],
            ['key' => 'beginner-frontend-8', 'title' => 'Component Props Demo', 'description' => 'Demonstrate props usage with parent-child components. Requirements: (1) Create UserCard component that accepts props: name, email, age, role, onEdit (callback function). (2) Display props: show name in heading, email and age in paragraph, role as badge. (3) Parent component (App): render 3 UserCard components with different data, pass different props to each. (4) Callback props: UserCard has "Edit" button, when clicked calls onEdit(name) callback passed from parent. Parent handles callback by showing alert or console.log. (5) Default props: if age not provided, show "N/A", if role not provided, default to "Member". React: UserCard.defaultProps = {role: "Member"}. Vue: props with default values. (6) Prop types validation: React use PropTypes to validate (name: PropTypes.string.isRequired, age: PropTypes.number, onEdit: PropTypes.func). Vue: define props with types (name: {type: String, required: true}). (7) Demonstrate prop drilling: Parent > UserList > UserCard, passing props through multiple levels. (8) Show children prop: UserCard can also accept children (custom content between opening/closing tags). (9) Edge cases: handle missing required props, show how app breaks with wrong prop types. (10) Document: create README explaining props concept, data flow (parent to child), callback functions (child to parent). Submit code with multiple examples of props usage.', 'type' => 'coding', 'difficulty' => 3, 'max_score' => 100],

            // ══════════════════════════════════════════════════════════════════
            // FRONTEND - INTERMEDIATE LEVEL TASKS
            // ══════════════════════════════════════════════════════════════════

            // Block 1: Advanced JavaScript & ES6+
            ['key' => 'intermediate-frontend-1', 'title' => 'Promise Chain Implementation', 'description' => 'Demonstrate mastery of Promises and async patterns. Requirements: (1) Sequential operations: fetch user data, then fetch user\s posts, then fetch first post\s comments using .then() chaining. Show each step in console. (2) Parallel operations: use Promise.all() to fetch multiple users simultaneously, show results when all complete. (3) Race condition: use Promise.race() to fetch from multiple APIs, use first response. (4) Error handling with Promises: use .catch() to handle errors at each step, use .finally() for cleanup. (5) Convert to async/await: rewrite the sequential example using async/await syntax with try/catch blocks. (6) Demonstrate error propagation: if fetch fails, catch error and show user-friendly message. (7) Create custom Promise: write function that returns Promise, resolves after delay (simulate API call). (8) Promise.allSettled(): fetch multiple resources, show which succeeded and which failed (don\'t stop on first error). (9) Practical example: build function that fetches with timeout (reject if takes > 5 seconds). (10) Compare callbacks vs Promises vs async/await with same operation. Submit code with extensive comments explaining each pattern.', 'type' => 'coding', 'difficulty' => 3, 'max_score' => 100],
            ['key' => 'intermediate-frontend-1', 'title' => 'Module System Demo', 'description' => 'Build a modular utility library demonstrating ES6 modules. Requirements: (1) Project structure: src/utils/string.js, src/utils/array.js, src/utils/date.js, src/index.js. (2) Named exports: in string.js export multiple functions (capitalize, truncate, slugify). In array.js export (chunk, unique, flatten). (3) Default export: in date.js export default formatter object. (4) Import examples: import all (import * as strings from \'./utils/string\'), import specific (import {capitalize} from \'./utils/string\'), import default (import dateFormatter from \'./utils/date\'). (5) Re-exports: create src/utils/index.js that re-exports all utilities (export * from \'./string\', export {default as dateFormatter} from \'./date\'). Single entry point for users. (6) Circular dependency handling: create two modules that import each other, show how to avoid issues. (7) Dynamic imports: use import() function to lazy load modules (const module = await import(\'./heavy-module.js\')). (8) Tree shaking demo: build with Vite/webpack, show unused exports are removed from bundle. (9) Module scope: demonstrate variables in modules are private by default. (10) Document module patterns and best practices. Submit complete modular library with build output showing tree shaking.', 'type' => 'project', 'difficulty' => 3, 'max_score' => 100],
            ['key' => 'intermediate-frontend-1', 'title' => 'Destructuring & Spread Patterns', 'description' => 'Master advanced destructuring and spread operators. Requirements: (1) Object destructuring: const {name, age, email} = user; extract properties with different names (const {name: userName} = user), provide defaults ({role = \'member\'} = user). (2) Nested destructuring: const {address: {city, country}} = user; extract from nested objects. (3) Array destructuring: const [first, second, ...rest] = numbers; skip elements with comma (const [, , third] = arr). (4) Function parameters: function displayUser({name, email}) - destructure in parameter. (5) Object spread: merge objects (const merged = {...defaults, ...userSettings}), clone object (const copy = {...original}), override properties. (6) Array spread: combine arrays (const all = [...arr1, ...arr2]), copy array, pass array elements as arguments (Math.max(...numbers)). (7) Rest parameters: function sum(...numbers) collects unlimited arguments. (8) Practical examples: swap variables ([a, b] = [b, a]), extract specific keys (const {id, ...userWithoutId} = user), conditional spread (const obj = {...base, ...(condition && {extra: value})}). (9) Performance consideration: when spread creates new object vs when to mutate. (10) Create interactive demo showing 10+ real-world use cases with before/after code comparison. Submit comprehensive examples with explanations.', 'type' => 'coding', 'difficulty' => 3, 'max_score' => 100],

            // Block 2: TypeScript Essentials
            ['key' => 'intermediate-frontend-2', 'title' => 'TypeScript Types & Interfaces', 'description' => 'Convert a JavaScript project to TypeScript with proper types. Requirements: (1) Setup: initialize TypeScript (tsc --init), configure tsconfig.json with strict mode, target ES2020, module ESNext. (2) Basic types: annotate variables (let name: string, age: number, isActive: boolean, items: string[]). (3) Interfaces: define User interface {id: number, name: string, email: string, role: \'admin\' | \'user\'}. Define Product, Order interfaces. (4) Type aliases: type ID = string | number; type Status = \'pending\' | \'approved\' | \'rejected\'; (5) Union types: function process(id: string | number), use type guards to narrow (if (typeof id === \'string\')). (6) Intersection types: type Admin = User & {permissions: string[]}; combine types. (7) Optional and readonly: interface Config {apiUrl: string, timeout?: number, readonly version: string}. (8) Function types: type Calculator = (a: number, b: number) => number; (9) Array and tuple types: type Coordinates = [number, number]; const point: Coordinates = [10, 20]. (10) Convert at least 3 JS files with 0 TypeScript errors in strict mode. Submit project showing proper type usage throughout.', 'type' => 'project', 'difficulty' => 4, 'max_score' => 100],
            ['key' => 'intermediate-frontend-2', 'title' => 'Generic Functions & Classes', 'description' => 'Implement generic utilities demonstrating TypeScript generics. Requirements: (1) Generic function: function identity<T>(value: T): T - works with any type while preserving it. (2) Generic array function: function first<T>(arr: T[]): T | undefined - returns first element with correct type. (3) Generic map function: function map<T, U>(arr: T[], fn: (item: T) => U): U[] - transforms array, types inferred correctly. (4) Generic filter: function filter<T>(arr: T[], predicate: (item: T) => boolean): T[]. (5) Generic class: class Stack<T> with push(item: T), pop(): T | undefined, peek(): T | undefined. Test with Stack<number>, Stack<string>. (6) Generic interface: interface Repository<T> {getAll(): Promise<T[]>, getById(id: number): Promise<T>, create(item: T): Promise<T>}. Implement for User and Product types. (7) Constraints: function getProperty<T, K extends keyof T>(obj: T, key: K) - only allow valid keys. (8) Default generic types: class Container<T = string> - defaults to string if not specified. (9) Multiple type parameters: function merge<T, U>(obj1: T, obj2: U): T & U. (10) Test all generics with different types, verify type safety and inference. Submit well-typed generic utilities with examples.', 'type' => 'coding', 'difficulty' => 4, 'max_score' => 100],

            // Block 3: Framework Mastery
            ['key' => 'intermediate-frontend-3', 'title' => 'Custom Hook/Composable', 'description' => 'Create reusable custom hooks (React) or composables (Vue). Requirements: (1) useFetch hook: const {data, loading, error, refetch} = useFetch(url). Handles fetching, loading state, error state, provides refetch function. (2) useLocalStorage hook: const [value, setValue] = useLocalStorage(\'key\', defaultValue). Syncs state with localStorage, updates on storage events from other tabs. (3) useDebounce hook: const debouncedValue = useDebounce(inputValue, 500). Returns value that only updates after delay. Useful for search inputs. (4) useMediaQuery hook: const isMobile = useMediaQuery(\'(max-width: 768px)\'). Responds to screen size changes. (5) Implementation details: handle cleanup (useEffect return function), handle dependencies correctly, handle edge cases (component unmounts during fetch). (6) Generic hook: make useFetch generic to work with any data type: useFetch<User>(url). (7) Error handling: retry logic, timeout handling, abort on unmount (AbortController). (8) Testing: write tests for each hook using React Testing Library or Vue Test Utils. (9) Documentation: document each hook with JSDoc comments, usage examples, parameter types. (10) Create demo app using all hooks together. Submit hooks with tests and demo.', 'type' => 'coding', 'difficulty' => 4, 'max_score' => 100],
            ['key' => 'intermediate-frontend-3', 'title' => 'Multi-Page Router App', 'description' => 'Build a multi-page application with client-side routing. Requirements: (1) Install router: React Router or Vue Router. (2) Pages: Home (landing page), About (company info), Products (product list), ProductDetail (dynamic route /products/:id), NotFound (404 page). (3) Router configuration: define all routes, set up nested routes if needed, set up route guards. (4) Navigation: create Nav component with links using Link/RouterLink (not <a>), highlight active route. (5) Dynamic routing: ProductDetail page reads :id parameter from URL, fetches product data based on ID, shows loading state, handles invalid ID (404). (6) Programmatic navigation: redirect after form submission (useNavigate() or router.push()), go back button (history.back()). (7) Route guards: protect /admin route, redirect to login if not authenticated, use beforeEnter or protected route wrapper. (8) Nested routes: Products layout with child routes: /products (list), /products/:id (detail), shared layout/sidebar. (9) 404 handling: catch-all route (*) renders NotFound component. (10) URL query params: Products page filters using ?category=electronics&sort=price, read with useSearchParams() or route.query. (11) Lazy loading: code-split routes using React.lazy() or Vue\s dynamic import for better performance. Test all navigation, verify URLs update correctly, test browser back/forward. Submit complete router app.', 'type' => 'project', 'difficulty' => 4, 'max_score' => 100],
            ['key' => 'intermediate-frontend-3', 'title' => 'Context/Provide-Inject Pattern', 'description' => 'Implement theme switcher using Context API (React) or Provide/Inject (Vue). Requirements: (1) Create ThemeContext: holds theme state ("light" or "dark"), provides toggleTheme function. (2) ThemeProvider component: wraps app, manages theme state, provides value to children. (3) Theme state: useState hook for current theme, initial value from localStorage (const [theme, setTheme] = useState(localStorage.getItem(\'theme\') || \'light\')). (4) Toggle function: switches between light/dark, saves to localStorage, updates CSS variables or class on <body>. (5) Consumer components: create Button, Card, Header components that useContext(ThemeContext) or inject(\'theme\') to get current theme and apply appropriate styles. (6) CSS variables approach: define --bg-color, --text-color, --border-color in :root for each theme, update based on theme state. (7) Persist preference: save theme to localStorage on change, load on app mount, sync across browser tabs (storage event listener). (8) System preference: detect user\s OS theme preference using matchMedia(\'(prefers-color-scheme: dark)\'), use as initial value. (9) Smooth transition: add transition: background-color 0.3s ease to prevent jarring theme switches. (10) Multiple contexts: also create UserContext for auth state, demonstrate consuming multiple contexts. Submit complete theme system with at least 3 pages showing theme switching working.', 'type' => 'coding', 'difficulty' => 3, 'max_score' => 100],

            // Block 4: State Management
            ['key' => 'intermediate-frontend-4', 'title' => 'Global State Store', 'description' => 'Build a shopping cart using Redux, Zustand, or Pinia. Requirements: (1) Setup: install state library, create store file. (2) State structure: {items: [{id, name, price, quantity, image}], total: number}. (3) Actions/mutations: addToCart(product), removeFromCart(id), updateQuantity(id, quantity), clearCart(). (4) Selectors: getCartItems, getCartTotal, getItemCount. (5) Components: ProductList (displays products with "Add to Cart" button), Cart (shows cart items with quantity controls), CartSummary (shows total, item count). (6) Add to cart logic: if item exists, increment quantity; if new, add with quantity 1. (7) Update quantity: input field to change quantity, buttons for +1/-1, min quantity is 1. (8) Remove item: X button with confirmation dialog. (9) Persist to localStorage: save cart state on every change using middleware (Redux: redux-persist, Zustand: persist middleware), load on app init. (10) Cart badge: show item count on cart icon in navigation, updates reactively. (11) Calculations: automatically recalculate total when items change, show formatted price ($XX.XX). Test: add items, update quantities, remove items, refresh page (cart persists), clear cart. Submit complete cart implementation with state management.', 'type' => 'project', 'difficulty' => 4, 'max_score' => 100],
            ['key' => 'intermediate-frontend-4', 'title' => 'Async State Actions', 'description' => 'Handle async operations in state management. Requirements: (1) State shape: {products: [], loading: false, error: null}. (2) Async action: fetchProducts - sets loading=true, fetches from API, on success sets products and loading=false, on error sets error and loading=false. (3) Redux Thunk/RTK Query/Pinia actions: implement async action creator that returns function (Redux Thunk) or use createAsyncThunk (RTK). (4) Loading states: show spinner when loading=true, show products when loaded, show error message if error exists. (5) Caching: don\'t refetch if products already loaded, add refresh button to force refetch. (6) Optimistic updates: when creating product, add to state immediately (before API response), revert if API fails. Show pending state with gray background. (7) Debouncing: search input triggers fetchProducts with query, debounce by 500ms so it doesn\'t fire on every keystroke. (8) Error handling: retry logic (auto-retry failed requests up to 3 times), show toast notification on error, clear error when retrying. (9) Action status tracking: track status for each action (idle/loading/success/error), show per-item loading state for delete actions. (10) DevTools: use Redux DevTools or Vue DevTools to inspect state changes, show before/after state for each action. Document async patterns used. Submit app demonstrating all async patterns.', 'type' => 'coding', 'difficulty' => 4, 'max_score' => 100],

            // Block 5: API Integration
            ['key' => 'intermediate-frontend-5', 'title' => 'REST API Client', 'description' => 'Build a robust API client module with axios. Requirements: (1) Base instance: create axios instance with baseURL, default headers (Content-Type, Accept). (2) Request interceptor: add auth token to headers if exists (Authorization: Bearer token), log requests in dev mode. (3) Response interceptor: extract data from response (return response.data), handle common error statuses (401: logout user, 403: show forbidden message, 500: show generic error). (4) Request/response transforms: automatically camelCase response keys, snake_case request keys for API convention. (5) Error handling: custom error class (class APIError extends Error), categorize errors (NetworkError, ValidationError, ServerError), provide user-friendly messages. (6) Retry logic: retry failed requests up to 3 times with exponential backoff (1s, 2s, 4s), only retry on network errors and 5xx errors (not 4xx). (7) Timeout: set request timeout (10 seconds), handle timeout errors specifically. (8) Cancellation: use AbortController to cancel requests, cancel pending requests when component unmounts or new request starts. (9) API methods: create wrapper functions (api.get, api.post, api.put, api.delete). (10) Typed responses: use TypeScript generics for type-safe API calls. Document setup and usage in README. Submit complete API client with examples.', 'type' => 'coding', 'difficulty' => 4, 'max_score' => 100],
            ['key' => 'intermediate-frontend-5', 'title' => 'Data Fetching UI', 'description' => 'Create a comprehensive data listing page with all UX features. Requirements: (1) Fetch data from API (JSONPlaceholder or your own API) on mount. (2) Loading state: show skeleton loading UI (gray boxes mimicking content layout) while fetching, smooth transition when data loads. (3) Error state: if fetch fails, show error card with message, retry button, illustration/icon. (4) Empty state: if data array is empty, show No items found with illustration and CTA button. (5) Pagination: display 10 items per page, numbered page buttons (1 2 3 ... 10), prev/next buttons, show Page X of Y and Showing X-Y of Z items, disable buttons at boundaries. (6) Search: input field filters items by name/title, searches as you type (debounced), shows No results for query if no matches, clear button (X) to reset search. (7) Filters: dropdown to filter by category, multi-select checkboxes for tags/types, apply filters button, show count of active filters, clear all filters button. (8) Sorting: dropdown to sort by (Name A-Z, Name Z-A, Newest, Oldest), apply sorting reactively. (9) URL sync: sync pagination, search, filters to URL query params, shareable links, browser back/forward works. (10) Performance: virtualization for large lists (only render visible items). Test with 100+ items dataset. Submit complete listing page with all features.', 'type' => 'project', 'difficulty' => 4, 'max_score' => 100],
            ['key' => 'intermediate-frontend-5', 'title' => 'WebSocket Chat UI', 'description' => 'Build real-time chat interface using WebSockets. Requirements: (1) Setup WebSocket connection: connect to ws://localhost:3000 or wss://echo.websocket.org for testing. (2) Connection status: show indicator (Connected: green dot, Connecting: yellow, Disconnected: red), display in header. (3) Send message: input field + send button, press Enter to send, clear input after sending. (4) Receive messages: listen to WebSocket message events, append to messages array, auto-scroll to bottom when new message arrives. (5) Message display: show messages in chat bubbles, own messages aligned right (blue), others aligned left (gray), show timestamp (HH:MM format), show sender name. (6) Online users: if server sends user list, display online users sidebar with count and avatars. (7) Typing indicator: send "typing" event when user types, show "User is typing..." when received, clear after 3 seconds of inactivity. (8) Reconnection: if connection drops, auto-reconnect with exponential backoff, show "Attempting to reconnect..." banner, queue messages sent while disconnected, send when reconnected. (9) Error handling: handle connection errors, message send failures, show error toast. (10) UI polish: smooth animations for new messages, sound notification (optional), emoji picker. Test with multiple browser tabs to simulate multiple users. Submit chat UI with WebSocket integration.', 'type' => 'project', 'difficulty' => 4, 'max_score' => 100],

            // Block 6: UI/UX & Design Systems
            ['key' => 'intermediate-frontend-6', 'title' => 'Component Library', 'description' => 'Build a mini component library with reusable UI components. Requirements: (1) Components to build: Button, Input, Card, Modal. (2) Button component: variants (primary, secondary, outline, ghost), sizes (sm, md, lg), states (default, hover, active, disabled, loading), full-width option, icon support (left/right). Props: variant, size, disabled, loading, onClick, children. (3) Input component: types (text, email, password, number), states (default, focus, error, disabled), label, error message, helper text, prefix/suffix icons. Handle value and onChange. (4) Card component: header, body, footer slots, hover effects, elevated/flat variants, clickable option, image support. (5) Modal component: overlay with backdrop, close button (X), close on backdrop click (optional), close on ESC key, focus trap (tab cycles within modal), prevent body scroll when open, animations (fade in/slide up). (6) Consistent styling: use CSS variables for colors (--primary, --error, --text), spacing scale (--space-1 to --space-8), border radius (--radius-sm, --radius-md). (7) Theme support: light/dark mode compatible. (8) Accessibility: proper ARIA labels, keyboard navigation, focus states, semantic HTML. (9) TypeScript: fully typed props with interfaces. (10) Storybook: create stories showing all variants and states. Submit component library with Storybook documentation.', 'type' => 'project', 'difficulty' => 4, 'max_score' => 100],
            ['key' => 'intermediate-frontend-6', 'title' => 'Accessible Components', 'description' => 'Make components fully accessible per WCAG 2.1 AA standards. Requirements: (1) Keyboard navigation: all interactive elements focusable with Tab, activate with Enter/Space, close modals with ESC, navigate dropdowns with arrow keys. (2) Focus management: visible focus indicators (outline or ring), focus trap in modals (focus stays within until closed), return focus to trigger element when closing modal. (3) ARIA attributes: use aria-label for icon-only buttons, aria-labelledby for modal titles, aria-describedby for error messages and hints, aria-hidden for decorative elements, aria-expanded for collapsible sections, aria-live for dynamic content updates. (4) Semantic HTML: use <button> not <div> for buttons, use <nav> for navigation, proper heading hierarchy (h1-h6). (5) Form accessibility: associate labels with inputs (for/id or wrap), mark required fields (required attribute + aria-required), announce errors to screen readers (aria-invalid, role="alert"), group related fields (fieldset/legend). (6) Color contrast: text has 4.5:1 contrast ratio, UI components have 3:1, test with contrast checker. (7) Screen reader testing: test with NVDA/JAWS (Windows) or VoiceOver (Mac), verify all content is announced correctly, interactive elements have clear labels. (8) Focus indicators: :focus-visible for keyboard-only focus styles (not on mouse click). (9) Alt text: descriptive alt text for images, empty alt for decorative images. (10) Use axe DevTools to audit, fix all issues. Submit accessibility report with before/after scores.', 'type' => 'coding', 'difficulty' => 4, 'max_score' => 100],

            // Block 7: Performance Optimization
            ['key' => 'intermediate-frontend-7', 'title' => 'Code Splitting Implementation', 'description' => 'Optimize bundle size with code splitting strategies. Requirements: (1) Route-based splitting: use React.lazy() and Suspense or Vue\s defineAsyncComponent to split routes. Each route loads its own chunk only when visited. (2) Component-based splitting: lazy load heavy components (charts, editors, large modals) that aren\'t immediately visible. (3) Vendor splitting: separate node_modules into vendor chunk so app code changes don\'t bust vendor cache. Configure in Vite/webpack. (4) Dynamic imports: use import() syntax for conditional modules (load module only if user has permission). (5) Bundle analysis: generate bundle report using vite-plugin-visualizer or webpack-bundle-analyzer, identify largest chunks, show before/after sizes. (6) Loading states: show loading spinner or skeleton for lazy components, use Suspense fallback. (7) Prefetching: prefetch important routes on hover (<link rel="prefetch">), preload critical resources. (8) Measure impact: use Lighthouse to measure before/after performance scores, show Time to Interactive improvement, reduce initial JS from 500KB to <200KB. (9) Chunk naming: name chunks meaningfully (/* webpackChunkName: "admin" */). (10) Error boundaries: wrap lazy components in error boundary to handle loading failures. Document bundle size reduction achieved (aim for 50%+ reduction in initial load). Submit before/after analysis.', 'type' => 'coding', 'difficulty' => 4, 'max_score' => 100],
            ['key' => 'intermediate-frontend-7', 'title' => 'Image Optimization', 'description' => 'Implement comprehensive image optimization. Requirements: (1) Lazy loading: use loading="lazy" attribute on images below fold, or Intersection Observer for custom lazy loading. Only load images when visible in viewport. (2) Responsive images: use srcset for different screen densities (<img srcset="image-1x.jpg 1x, image-2x.jpg 2x">), use sizes attribute for different viewport widths. (3) Picture element: <picture> with multiple <source> elements for art direction (different crops for mobile/desktop) and format fallbacks (WebP with JPG fallback). (4) Modern formats: use WebP or AVIF for better compression (50% smaller than JPG), provide fallbacks for unsupported browsers. (5) Image CDN: use service like Cloudinary or imgix with URL transforms (resize, format, quality). Example: img.src = https://cdn.example.com/image.jpg?w=400&q=80&f=webp. (6) Placeholder strategies: blur-up (tiny blurred placeholder loads first, sharp image replaces it), solid color placeholder from dominant color, or skeleton placeholder. (7) Dimensions: always specify width and height attributes to prevent layout shift (CLS), use aspect-ratio CSS. (8) Compression: optimize images with tools (ImageOptim, Squoosh) before uploading, aim for <100KB per image. (9) SVG optimization: minify SVGs with SVGO, use inline SVG for icons that need styling. (10) Performance measurement: use Lighthouse to measure image performance, show metrics improvement (LCP, CLS). Submit demo with 20+ optimized images showing techniques.', 'type' => 'coding', 'difficulty' => 3, 'max_score' => 100],

            // Block 8: Testing Fundamentals
            ['key' => 'intermediate-frontend-8', 'title' => 'Unit Test Suite', 'description' => 'Write comprehensive unit tests for utility functions and React hooks. Requirements: (1) Setup: Jest + React Testing Library (or Vitest), configure test environment. (2) Test utility functions: test pure functions (formatCurrency, validateEmail, calculateTotal). For each: test happy path, edge cases (empty input, null, undefined), error cases. Aim for 100% coverage. (3) Test React hooks: test custom useFetch hook - mock fetch, test loading state, test success state with data, test error state, test refetch function. Use @testing-library/react-hooks or renderHook from RTL. (4) Test structure: describe blocks for organization, it/test for individual cases, clear test names ("should return formatted currency", "should handle null input"). (5) Assertions: use expect matchers (toBe, toEqual, toContain, toHaveBeenCalled), test both return values and side effects. (6) Mocking: mock API calls with jest.mock, mock setTimeout/setInterval, mock localStorage. (7) Test coverage: run coverage report (jest --coverage), view HTML coverage report, ensure 80%+ coverage for critical code. (8) Snapshot testing: create snapshots for complex data structures, update when intentionally changed. (9) Testing async code: use async/await in tests, waitFor for async updates. (10) CI integration: add test script to package.json, tests run in CI before deployment. Submit test suite with coverage report showing 80%+ coverage.', 'type' => 'coding', 'difficulty' => 4, 'max_score' => 100],
            ['key' => 'intermediate-frontend-8', 'title' => 'Component Testing', 'description' => 'Test React/Vue components thoroughly. Requirements: (1) Setup: React Testing Library or Vue Test Utils. (2) Rendering tests: render component with default props, verify elements are present (getByText, getByRole), verify correct initial state. (3) Props testing: render with different props, verify component adapts (different variants, sizes, disabled state). (4) User interaction: simulate button clicks (fireEvent.click or userEvent.click), verify onClick handler called, verify state updates. (5) Form testing: type into input (userEvent.type), submit form, verify validation, verify submitted data. (6) Async testing: test component that fetches data, wait for loading to finish (waitFor), verify data displayed, test error state. (7) Conditional rendering: test components render differently based on props/state, verify elements appear/disappear. (8) Testing hooks: test components using custom hooks, verify hook behavior through component. (9) Accessibility testing: use jest-axe to check for a11y violations in rendered components. (10) Snapshot tests: snapshot complex component output, review changes in snapshots. Test at least 5 components (Button, Input, Card, Modal, Form). Each component has 5+ test cases. Submit test suite with all components covered.', 'type' => 'project', 'difficulty' => 4, 'max_score' => 100],
            ['key' => 'intermediate-frontend-8', 'title' => 'E2E Test Flow', 'description' => 'Write end-to-end tests for critical user journey using Cypress or Playwright. Requirements: (1) Setup: install Cypress or Playwright, configure base URL, viewport size. (2) Test scenario: complete user flow for e-commerce site - land on homepage, search for product, view product detail, add to cart, proceed to checkout, fill form, place order. (3) Test structure: before hook to visit site and set up state, afterEach hook to clear cookies/storage. (4) Selectors: use data-testid attributes for stable selectors, avoid brittle class/ID selectors. (5) Assertions: verify URL changes with should include products, verify elements visible with get and should be.visible, verify text content, verify form values. (6) User actions: click buttons, type in inputs, select dropdown, check checkbox, upload file. (7) Wait strategies: wait for API calls to complete using intercept and wait, wait for elements to appear using get and should exist, explicit waits when needed. (8) Network mocking: use cy.intercept for Cypress or page.route for Playwright to mock API responses, test with mocked data for consistency. (9) Visual testing: take screenshots at key steps using screenshot command, optionally use Percy for visual regression. (10) CI integration: run tests in headless mode in CI, generate video/screenshot artifacts on failure. Test should complete in under 60 seconds. Submit E2E test covering complete user flow.', 'type' => 'coding', 'difficulty' => 4, 'max_score' => 100],

            // ══════════════════════════════════════════════════════════════════
            // FRONTEND - ADVANCED LEVEL TASKS
            // ══════════════════════════════════════════════════════════════════

            // Block 1: Advanced Rendering Strategies
            ['key' => 'advanced-frontend-1', 'title' => 'SSR Application', 'description' => 'Build server-side rendered app with Next.js or Nuxt.js. Requirements: (1) Server-side data fetching: use getServerSideProps (Next) or asyncData (Nuxt) to fetch data on server before rendering. (2) SEO optimization: dynamic meta tags (title, description, OG tags) per page, structured data (JSON-LD), sitemap generation. (3) Hydration: server renders HTML, client hydrates without flash of unstyled content, avoid hydration mismatches. (4) Error boundaries: catch errors in SSR, show error page, do not crash server. (5) Performance: time to first byte < 200ms, first contentful paint < 1s, implement streaming SSR if possible. (6) API routes: serverless functions for backend (Next.js API routes or Nuxt server middleware). (7) Authentication: handle auth on server, protected pages redirect on server (no flash of login page). (8) Caching: cache rendered pages (ISR/stale-while-revalidate), CDN edge caching. (9) Dynamic imports: code-split client-side only components. (10) Compare metrics with CSR: LCP, TTI, SEO score. Submit SSR app with performance audit.', 'type' => 'project', 'difficulty' => 5, 'max_score' => 100],
            ['key' => 'advanced-frontend-1', 'title' => 'Static Generation with ISR', 'description' => 'Implement blog with Static Site Generation + Incremental Static Regeneration. Requirements: (1) SSG: use getStaticProps to fetch blog posts at build time, generate static HTML for each post. (2) Dynamic routes: getStaticPaths generates paths for all posts, fallback: \"blocking\" for new posts. (3) ISR: revalidate every 60 seconds, stale content served while regenerating in background. (4) Build process: build generates HTML for 100+ posts, measure build time. (5) On-demand revalidation: API route to trigger regeneration when content updated (revalidate specific paths). (6) Fallback pages: loading state while generating new pages on-demand. (7) Preview mode: bypass static generation for preview (show draft content). (8) Image optimization: next/image for automatic optimization, lazy loading, WebP. (9) Incremental adoption: mix SSG, ISR, SSR in same app based on needs. (10) Deployment: deploy to Vercel/Netlify, configure cache headers. Compare SSG vs SSR performance. Submit blog with ISR.', 'type' => 'project', 'difficulty' => 5, 'max_score' => 100],

            // Block 2: Design Systems at Scale
            ['key' => 'advanced-frontend-2', 'title' => 'Storybook Component Docs', 'description' => 'Set up Storybook for component library. Requirements: (1) Install Storybook: npx storybook init, configure for React/Vue. (2) Stories: write stories for each component showing all variants (Button: primary, secondary, sizes, disabled, loading). Use CSF (Component Story Format). (3) Controls: add controls addon for interactive prop editing, define arg types with descriptions. (4) Documentation: write MDX docs for each component (usage examples, props table, dos and do nots). (5) Accessibility addon: test components with a11y addon, fix violations, show a11y score in Storybook. (6) Visual regression: integrate Chromatic or Percy for visual testing, catch unintended UI changes. (7) Theming: demonstrate components in light/dark themes, toggle in Storybook. (8) Composition: show compound component patterns, complex compositions. (9) Viewport addon: test responsive behavior at different screen sizes. (10) Deploy: publish Storybook to static hosting, share with team. Submit Storybook with 10+ documented components.', 'type' => 'project', 'difficulty' => 4, 'max_score' => 100],
            ['key' => 'advanced-frontend-2', 'title' => 'Design Tokens System', 'description' => 'Implement design tokens for scalable theming. Requirements: (1) Token structure: define tokens in JSON/YAML (colors, typography, spacing, shadows, borders). Example: {\"color\": {\"brand\": {\"primary\": \"#3B82F6\"}}}. (2) Semantic tokens: map design tokens to semantic names (--button-bg: var(--color-brand-primary)). (3) Themes: define multiple themes (light, dark, high-contrast), swap token values while keeping names. (4) Build system: use Style Dictionary or Theo to transform tokens into CSS variables, SCSS variables, JS objects. (5) Platform support: generate tokens for web (CSS), mobile (iOS/Android), design tools (Figma). (6) Token categories: color (brand, semantic), typography (font-family, size, weight, line-height), spacing (scale from 4px to 64px), elevation (shadows), radius. (7) Documentation: auto-generate token documentation showing all values, visual swatches. (8) Version control: tokens in repo, follow semver, publish as npm package. (9) Theming runtime: switch themes dynamically, persist preference. (10) Type safety: TypeScript types for token names. Submit design token system with at least 2 themes.', 'type' => 'project', 'difficulty' => 5, 'max_score' => 100],

            // Block 3: Advanced State Patterns
            ['key' => 'advanced-frontend-3', 'title' => 'State Machine Implementation', 'description' => 'Model complex UI with XState state machine. Requirements: (1) Multi-step form wizard: steps (personal info → contact → payment → confirmation), model as state machine with states for each step. (2) State transitions: next/prev actions, validation guards (cannot proceed if invalid), conditional transitions. (3) State context: store form data in machine context, update on input changes. (4) Guards: check conditions before transition (hasValidEmail, hasAgreedToTerms). (5) Actions: side effects on transition (save to localStorage, analytics tracking). (6) Services: async operations (validate email with API), invoke services in states. (7) Parallel states: loading state parallel to main flow (can be loading from any step). (8) History states: back button returns to previous state correctly. (9) Visualization: use XState visualizer to see state diagram. (10) Testing: test state machine logic independently of UI. Submit wizard using XState with complex flow.', 'type' => 'project', 'difficulty' => 5, 'max_score' => 100],
            ['key' => 'advanced-frontend-3', 'title' => 'Offline-First Data Sync', 'description' => 'Build offline-capable app with sync. Requirements: (1) Local storage: use IndexedDB (Dexie.js) to store data locally, works offline. (2) Offline detection: listen to online/offline events, show banner when offline. (3) Offline CRUD: create/update/delete records locally when offline, queue operations. (4) Background sync: when back online, sync queued operations to server, use Service Worker Background Sync API. (5) Optimistic updates: update UI immediately, sync in background, show syncing indicator. (6) Conflict resolution: handle conflicts when local and server data differ (last-write-wins, manual merge, or version vectors). (7) Sync status: show which records are synced/pending/conflicted, retry failed syncs. (8) Differential sync: only sync changed records, send diffs not full documents. (9) Service Worker: install SW for offline asset caching, cache-first strategy for API responses. (10) Progressive enhancement: app works fully offline, better experience online. Test by toggling network in DevTools. Submit offline-first app.', 'type' => 'project', 'difficulty' => 5, 'max_score' => 100],

            // Block 4: Real-Time & Rich Interfaces
            ['key' => 'advanced-frontend-4', 'title' => 'Real-Time Collaboration', 'description' => 'Build collaborative editing feature (Google Docs-style). Requirements: (1) Operational Transformation or CRDT: handle concurrent edits from multiple users, resolve conflicts algorithmically. (2) Real-time sync: use WebSockets to broadcast changes, sub-100ms latency. (3) Presence: show online users with avatars, show who is typing/editing what section. (4) Cursors: display cursors of other users in real-time, color-coded by user. (5) Change broadcast: when user types, send change operation (insert char at position X), do not send entire doc. (6) Offline handling: buffer changes when disconnected, sync when reconnected, merge changes. (7) Version history: track document versions, allow reverting to previous state. (8) Locking: optional section locking to prevent conflicts. (9) Performance: handle large documents (1000+ paragraphs), debounce broadcasts. (10) Testing: test with multiple browser windows, simulate network latency. Submit collaborative editor with at least 2 concurrent users.', 'type' => 'project', 'difficulty' => 5, 'max_score' => 100],
            ['key' => 'advanced-frontend-4', 'title' => 'Canvas/WebGL Visualization', 'description' => 'Create interactive data visualization with Canvas or Three.js. Requirements: (1) Render large dataset: visualize 10,000+ data points (scatter plot, force-directed graph, or 3D visualization). (2) Canvas API: use 2D context for drawing, implement zoom/pan, handle high-DPI displays (devicePixelRatio). (3) Performance: render at 60 FPS, use requestAnimationFrame, implement viewport culling (only render visible items). (4) Interactivity: hover shows tooltip, click selects item, drag to pan, scroll to zoom. (5) WebGL/Three.js: render 3D scene, custom shaders for effects, camera controls. (6) Data updates: animate transitions when data changes, smooth interpolation. (7) Responsive: resize canvas on window resize, maintain aspect ratio. (8) Hit detection: efficiently determine which item was clicked (spatial indexing, offscreen rendering). (9) Accessibility: provide text alternative, keyboard navigation for data points. (10) Optimization: use Web Workers for heavy calculations, separate rendering from computation. Submit visualization handling 10K+ items smoothly.', 'type' => 'project', 'difficulty' => 5, 'max_score' => 100],

            // Block 5: Frontend Security
            ['key' => 'advanced-frontend-5', 'title' => 'XSS Prevention Implementation', 'description' => 'Audit and secure app against XSS vulnerabilities. Requirements: (1) Content sanitization: sanitize user-generated content with DOMPurify before rendering, allow only safe HTML tags. (2) Avoid dangerouslySetInnerHTML: use textContent instead, if must use HTML, sanitize first. (3) CSP headers: implement Content-Security-Policy header (script-src "self", no inline scripts, nonce for needed scripts). (4) Input validation: validate all inputs on client and server, reject suspicious patterns. (5) Output encoding: properly encode data based on context (HTML escape, JavaScript escape, URL encode). (6) Safe DOM manipulation: use createElement/textContent instead of innerHTML with user data. (7) Template security: if using template literals, escape dynamic parts. (8) HTTP-only cookies: store auth tokens in HTTP-only cookies (not localStorage). (9) Testing: use automated XSS scanners, manual penetration testing with XSS payloads. (10) Security headers: X-Content-Type-Options, X-Frame-Options, Referrer-Policy. Submit security audit report showing vulnerabilities fixed.', 'type' => 'coding', 'difficulty' => 4, 'max_score' => 100],
            ['key' => 'advanced-frontend-5', 'title' => 'Secure Authentication Flow', 'description' => 'Implement production-grade secure authentication. Requirements: (1) Token storage: store access token in memory (React state), refresh token in HTTP-only cookie, never in localStorage. (2) Automatic refresh: before access token expires, use refresh token to get new access token silently. (3) Token rotation: server issues new refresh token on each use (prevents replay attacks). (4) Logout everywhere: endpoint to invalidate all user sessions, clear all refresh tokens. (5) CSRF protection: use CSRF tokens for state-changing operations, SameSite cookie attribute. (6) Secure headers: HTTPS only, HSTS header, secure cookie flags. (7) Session management: track active sessions, allow user to revoke specific devices. (8) Biometric/2FA: support WebAuthn for passwordless login, TOTP for 2FA. (9) Auth errors: do not leak info in error messages (\"invalid credentials\" not \"email not found\"). (10) Rate limiting: prevent brute force on login, implement exponential backoff on client. Test auth flow security thoroughly. Submit secure auth implementation.', 'type' => 'project', 'difficulty' => 5, 'max_score' => 100],

            // Block 6: Performance at Scale
            ['key' => 'advanced-frontend-6', 'title' => 'Virtualized List', 'description' => 'Implement virtual scrolling for 10,000+ items. Requirements: (1) Virtual scrolling: only render visible items (20-30), reuse DOM elements, smooth scrolling experience. (2) Variable heights: support dynamic item heights, measure and cache heights, recalculate on resize. (3) Scroll restoration: restore scroll position on navigation back, persist scroll state. (4) Search within list: jump to matching item, highlight results, scroll item into view. (5) Infinite scroll: load more items as user scrolls near bottom, show loading indicator. (6) Keyboard navigation: arrow keys to move selection, Enter to select, Home/End to jump, Page Up/Down. (7) Performance: 60 FPS scrolling, <16ms per frame, measure with Chrome DevTools Performance. (8) Accessibility: proper ARIA roles, screen reader announces current position (item X of Y). (9) Library or custom: use react-window/react-virtualized or implement custom solution. (10) Bonus: horizontal virtualization, grid virtualization. Test with 50,000 items list. Submit performant virtualized list.', 'type' => 'project', 'difficulty' => 5, 'max_score' => 100],
            ['key' => 'advanced-frontend-6', 'title' => 'Performance Monitoring', 'description' => 'Implement real-time performance monitoring. Requirements: (1) Web Vitals collection: measure LCP, FID, CLS using web-vitals library, send to analytics. (2) Custom metrics: track React component render time, API response time, route change time. (3) Performance budgets: set thresholds (LCP < 2.5s, FID < 100ms, CLS < 0.1, bundle < 300KB), fail build if exceeded. (4) RUM (Real User Monitoring): collect metrics from actual users in production, track by device/browser/region. (5) Performance API: use PerformanceMark, PerformanceMeasure for custom timings. (6) Long tasks: detect long tasks blocking main thread (>50ms), identify culprits. (7) Memory profiling: detect memory leaks, track heap size over time, alert on anomalies. (8) Bundle analysis: track bundle size over time, alert on 10%+ increase. (9) Reporting: dashboards showing trends, P50/P75/P95 percentiles, regressions. (10) Alerts: Slack/email when performance degrades, automated issue creation. Submit monitoring system with real metrics.', 'type' => 'coding', 'difficulty' => 4, 'max_score' => 100],

            // Block 7: Testing Strategy & CI
            ['key' => 'advanced-frontend-7', 'title' => 'Visual Regression Testing', 'description' => 'Set up visual regression testing pipeline. Requirements: (1) Tool: Playwright + Percy, Chromatic, or BackstopJS for screenshot comparison. (2) Baseline: capture baseline screenshots of all components/pages in stable state. (3) Change detection: on PR, capture new screenshots, compare with baseline pixel-by-pixel. (4) Review flow: show visual diffs in PR comments, approve/reject changes, update baseline if intentional. (5) Multiple viewports: test mobile, tablet, desktop viewports (375px, 768px, 1920px). (6) Cross-browser: test in Chrome, Firefox, Safari (if possible), catch browser-specific issues. (7) Component coverage: test all Storybook stories, test key user flows. (8) CI integration: run on every PR, block merge if regressions detected, parallel execution for speed. (9) Flake reduction: wait for animations to finish, hide dynamic content (dates, random IDs), use fixed viewport. (10) Performance: optimize screenshot count (test variants strategically), cache when possible. Submit visual testing setup integrated in CI.', 'type' => 'project', 'difficulty' => 5, 'max_score' => 100],
            ['key' => 'advanced-frontend-7', 'title' => 'Comprehensive Test Pipeline', 'description' => 'Build complete testing pipeline from unit to E2E. Requirements: (1) Unit tests: Jest + RTL for components and functions, 80%+ coverage, run in < 30s. (2) Integration tests: test multiple components together, test with mock API, test user flows. (3) E2E tests: Playwright/Cypress for critical paths (login, checkout, admin actions), run in < 5min. (4) Visual tests: as per previous task, catch UI regressions. (5) Accessibility tests: jest-axe + pa11y CI to catch a11y violations. (6) Type checking: TypeScript strict mode, no type errors. (7) Linting: ESLint + Prettier, enforce code style. (8) CI pipeline: GitHub Actions with stages (Lint → Unit → Integration → E2E → Visual), parallel where possible. (9) Coverage gates: require 80% coverage to merge, show coverage diff in PR. (10) Fast feedback: run unit tests on pre-commit hook, full suite on PR, E2E on main branch only. Optimize for developer experience (fast local tests, comprehensive CI tests). Submit complete pipeline config.', 'type' => 'project', 'difficulty' => 5, 'max_score' => 100],

            // Block 8: Architecture & Leadership
            ['key' => 'advanced-frontend-8', 'title' => 'Architecture Decision Record', 'description' => 'Write ADRs for major frontend architecture decisions. Requirements: (1) ADR format: Title, Status (proposed/accepted/deprecated), Context (problem statement), Decision (what was chosen), Consequences (pros/cons/risks). (2) Decisions to document: state management choice (why Redux/Zustand/Jotai?), styling approach (CSS Modules/Styled Components/Tailwind?), testing strategy, build tool, API client, routing solution. (3) At least 5 ADRs covering: (a) Why React/Vue/Angular? Compare alternatives, explain trade-offs. (b) State management: evaluate Redux, MobX, Zustand, Jotai - explain choice. (c) Styling: CSS-in-JS vs utility-first vs CSS Modules - list pros/cons. (d) Monorepo vs polyrepo for multi-package project. (e) TypeScript adoption: why strict mode, configuration choices. (4) Each ADR includes: current situation, options considered (minimum 2 alternatives), decision rationale, migration plan if applicable. (5) Store ADRs in docs/adrs/ directory, numbered sequentially (0001-state-management.md). (6) Link ADRs: reference related decisions, show decision evolution. (7) Living documents: update status when decisions change. Submit ADR collection for a real or hypothetical project.', 'type' => 'coding', 'difficulty' => 4, 'max_score' => 100],
            ['key' => 'advanced-frontend-8', 'title' => 'Migration Plan Document', 'description' => 'Create detailed migration plan from legacy to modern framework. Requirements: (1) Current state analysis: inventory of legacy app (AngularJS/jQuery/Backbone), size (LOC, number of pages/components), pain points, technical debt. (2) Target architecture: define end state (React/Vue + TypeScript + modern tooling), explain why chosen. (3) Migration strategies: evaluate approaches - (a) Big Bang (full rewrite), (b) Strangler Fig (gradual replacement), (c) Incremental (page by page). Choose and justify. (4) Phased approach: break into phases (Phase 1: setup infra + convert simple pages, Phase 2: complex features, Phase 3: cleanup legacy), 3-6 month timeline. (5) Coexistence strategy: run old and new apps side-by-side, routing between them, shared header/footer, gradual traffic shift. (6) Risk mitigation: identify risks (regressions, performance, team capacity), mitigation plans, rollback procedures. (7) Team enablement: training plan, coding standards, documentation, knowledge transfer. (8) Success metrics: define KPIs (page load time, bug rate, developer productivity), target improvements. (9) Rollback plan: if migration fails at any phase, how to safely revert. (10) Cost-benefit: estimate effort (developer months), expected benefits (performance, DX, velocity), ROI. Submit comprehensive migration plan document with timeline and resource estimates.', 'type' => 'coding', 'difficulty' => 5, 'max_score' => 100],
        ];

        foreach ($tasks as $task) {
            $block = $blocks->get($task['key']);

            if (!$block) {
                continue;
            }

            $metadata = [
                'requires_attachment' => true,
                'attachment_type' => 'url',
                'attachment_hint' => 'Submit your code via GitHub repository URL, CodeSandbox, or a downloadable zip link',
            ];

            // Add specific hints based on task type
            if ($task['type'] === 'project') {
                $metadata['attachment_hint'] = 'Submit a complete GitHub repository URL with README explaining setup and usage';
            } elseif ($task['type'] === 'coding') {
                $metadata['attachment_hint'] = 'Submit your code via GitHub Gist, repository, or CodeSandbox link';
            }

            Task::updateOrCreate(
                [
                    'roadmap_block_id' => $block->id,
                    'title' => $task['title'],
                ],
                [
                    'description' => $task['description'],
                    'type'        => $task['type'],
                    'difficulty'  => $task['difficulty'],
                    'max_score'   => $task['max_score'],
                    'is_active'   => true,
                    'metadata'    => $metadata,
                ]
            );
        }
    }
}

